---
layout: post
title:  TCP/IP 传输层
date:   2017-12-08 19:15:10
categories:  基础
tags:  NetWork
keywords: 
description:         
---

## 传输层

首先我们看看传输层在OSI 7层协议和TCP/IP 4层协议中所处的位置

![enter image description here](http://p7lixluhf.bkt.clouddn.com/OSI.jpg)

传输层面向它上面的应用层提供通信服务，它位于网络层之上，提供不同主机的进程之间的通信。

* **传输层**提供的是不同主机之间**端口和端口**之间的通信，而**网络层**提供的是**主机和主机**之间的通信。
* **复用和分用：** 复用指发送方不同的应用进程都可以使用同一个数据层传输协议传送数据；分用指接收方的传输层在剥去报文的首部之后才能把这些数据传到目的应用程序。
* 传输层会对收到的报文进行差错检测（首部和数据部分）。而网络层只检查IP数据报的首部。

Tips：
网络中通过IP address来识别不同的主机，通过端口号来识别主机中不同的进程。在网络中使用套接字（Socket）组合来识别端点。
```	
							套接字 = （主机IP address， 端口号）
```


## UDP
UDP只做了传输协议能够做的最少工作，只在IP数据报服务上增加了**复用和分用**、**差错检测**两个基本服务。

UDP的优点就是快，它无需建立链接，举个例子：

TCP建立连接，发现建立连接需要三个包的交互，这个应该是connect()完成的。

TCP发送数据然后看到自己的消息内容是一个包，对方没有数据，只有确认ACK，这是两个包，这个由 send () 触发。

TCP释放连接然后系统自动退出，虽然我的程序没有调用什么函数，但是系统自动帮我调用了 close () 函数，于是又触发了TCP 关闭连接，这是四个包。

于是把这三个阶段包的交换加在一起：3 + 2 + 4 = 9 （3次握手，4次挥手）

后来我又试试用UDP socket 编写聊天程序，直接调用一个函数Sendto() 就可以了（用IP访问），抓包一看，一个消息就是一个包，对方也没有确认，UDP就是加上一个封装头就出去了，不需要建立连接，自然也无需关闭连接。这样UDP的速度就快了很多。对于需要保证通信速度的应用，就应该使用UDP。


**UDP的首部只包含:UDP源端口号、UDP目的端口号、UDP报文长度（包括首部和数据）和校验和**

**对于接收到差错的UDP数据报，就直接丢弃，UDP是把数据直接发出去，而不管对方是不是在收信，就算是UDP无法送达，也不会产生ICMP差错报文**

### UDP疑问
1.为什么要使用UDP，直接发送IP分组不行吗？
不行。IP分组包含IP地址，该地址指向一台目的机器，但是不知道将数据报交给哪个进程。所以需要UDP，它包含目的端口，知道要交给的具体进程。此外，IP仅仅对头部做差错检测，UDP对整个数据报做差错检测。

## TCP
TCP是在不可靠的IP层上实现的可靠传输协议，它能解决传输的**可靠、有序、不丢失和不重复**的问题。

### TCP大体流程
* 1.双方建立连接
* 2.发送方给接受方TCP数据报，然后等待对方的确认TCP数据报，如果没有，就重新发，如果有，就发送下一个数据报。
* 3.接受方等待发送方的数据报，如果得到数据报并检验无误，就发送ACK(确认)数据报，并等待下一个TCP数据报的到来。直到接收到FIN(发送完成数据报)
* 4.中止连接

具体了解 TCP的链接和断开的过程：[三次握手，四次挥手](https://zfjxxx.github.io/2017-12-30-TCP34/)

当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能 及时收到一个确认，将重发这个报文段。
  
TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输 过程中的任何变化。如果收到段的检验和有差错， TCP将丢弃这个报文段和不确认收到此报文段（希望发送端超时并重发）。

既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段 的到达也可能会失序。如果必要， TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。TCP将所要传送的报文堪称是**字节**组成的数据流，并使没一个字节对应一个序号。

 TCP还能提供流量控制。TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。

TCP中保持可靠性的方式就是超时重发，这是有道理的，虽然TCP也可以用各种各样的ICMP报文来处理这些，但是这也不是可靠的，最可靠的方式就是只要不得到确认，就重新发送数据报，直到得到对方的确认为止。







