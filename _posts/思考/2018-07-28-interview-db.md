---
layout: post
title:  Interview Summary(DataBase)
date:   2018-07-28 19:15:10
categories:  思考
tags: 面经
keywords: interview
description: 
---

## 三范式
* 第一范式：所有属性都是不可分割的原子值
* 第二范式：要求非主属性完全依赖于主属性。所谓完全依赖是指不能存在仅依赖主关属性一部分的属性
* 第三范式：任何非主属性不依赖于其它非主属性

## 读写锁
* 读锁是共享的，多个用户可以同一时刻读取一个资源
* 写锁是排他的，同一时刻只有一个用户可以访问。

## ACID
原子性（Atomicity) 
事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。

一致性(Consistency) 
事务在完成时，必须使所有的数据都保持一致状态。只有在事物完成之后才能被所有使用者看见，保证了数据的完整性。例如从账户A转一笔钱到账户B上，如果账户A上的钱减少了，而账户B上的钱却没有增加，那么我们认为此时数据处于不一致的状态。

隔离性（Insulation） 
由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。也就是说一个事务操作的数据不会被其他实物看到和操作

持久性(Durability） 
事务完成之后，它对于系统的影响是永久性的。该修改即使出现致命的系统故障也将一直保持

## 隔离级别
* 读未提交：可以读到未提交事务的数据，也就是脏读，这个隔离级别性能最好，但是安全性低，很少使用。
* 读已提交:可避免发生脏读，解决方法：在A事务提交实物之前，不允许其他事务读取正在改动的数据。

但是会在一个事务内，读到其它事务提交的数据，导致执行两次同样的查询，读出不同的结果，也就是不可重复读。
* 可重复读：可避免脏读、不可重复读。解决方法：事务A完成最后一次读取数据之前，不允许其他事务修改正在读取的数据。

MySQL默认隔离级别。但是会有幻读的问题：当读取某个范围内的数据时，另一事务在范围内插入了新数据，当前事务再次读取的时候会产生幻行。
* 串行化:最高隔离级别，强制事务串行执行，给每一行数据都加锁，很少使用，除非是低并发、需要保证数据一致性才使用。

## 间隙锁
在InnoDB中，通过默认可重复读的隔离级别，并通过间隙锁的方式来防止幻读的出现。

间隙锁就是： A、B、C三行数据，我们将A和B，B和C之间的空隙封锁，这样就不能在AC之间插入数据了。

通过这种方法，其它事务就不能在范围查询时插入数据了。

## InnoDB 和 MyISAM
* **InnoDB**：MySQL的默认存储引擎；支持事务，对于InnoDB每一条SQL语言都默认封装成事务，自动提交；并且具有崩溃自动回复特性，默认实现的隔离级别是“可重复读”，InnoDB表是基于聚簇索引建立的（基于B+数结构）。
* **MyISAM**: 不支持事务和行级锁，只能对全表加锁，崩溃无法自动恢复。
* InnoDB不支持全文索引，MyISAM支持 （5.6InnoDB已经支持全文索引）
* InnoDB支持外键，MyISAM不支持 
* MyISAM锁的粒度是表级，而InnoDB支持行级锁定。
* InnoDB是事务安全型的，默认开启自动提交，MyISAM不支持事务
* MyISAM是按照数据插入的顺序存储在磁盘上,将索引存储到内存中，而数据直接存到硬盘；InnoDB是根据主键将数据存在B+树的叶子节点中，数据和索引存放在一起，都在内存中，然后再存到硬盘

![](http://p7lixluhf.bkt.clouddn.com/MySQLindex.PNG)

* Myisam的主键索引的叶子节点只存放数据在物理磁盘上的指针，二级索引也是一样的；Innodb的主键索引的叶子节点下面直接存放数据，二级索引的叶子节点存主键数据；

## 数据类型
* 整数类型：TINYINT,SMALLINT,MEDIUMINT,INT,BIGINT

分别占1个字节、2个字节、3个字节、4个字节、8个字节

* 浮点类型：FLOAT,DOUBLE

* 字符串类型：CHAR,VERCHAR，TEXT

CHAR存储长度不可变，长度一定的字符串，比如MD5后的密码，性别等。VERCHAR是可变长度的字符串，需要多用一个（字符串短于255）或者两个（字符串长于255）额外的字节存储字符串长度。

TEXT用于存储很大的字符串。
* 时间类型：DATE

## 索引
索引的优点：
* 1.加快查询速度，大大减少服务器需要扫描的数据量
* 2.将随机IO变成了顺序IO
* 3.索引对于InnoDB（对索引支持行级锁）非常重要，因为它可以让查询锁更少的行。

索引的缺点：
* 1.虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存索引文件
* 2.建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。
* 3.如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。
* 4.对于非常小的表，大部分情况下简单的全表扫描更高效；

### B+Tree索引
* B+Tree索引对索引列时顺序组织存储的，所以很适合查找范围数据。B+Tree所有索引数据都在叶子结点上，并且增加了顺序访问指针,每个叶子节点都有指向相邻叶子节点的指针。这样做是为了提高区间查询效率，例如查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。
* B-Tree索引适用于全键值，键值范围或者键前缀查找（前缀只能从左前缀开始）
* 除了按值查找之外，B-Tree索引还可以用于查询中的ORDER BY操作。
* 如果不是按照索引最左列开始查找，则无法使用索引（比如名字以x结尾的人）
* 不能跳过索引中的列。（比如以姓，名，生日三个键为索引，不能查找姓为A，生日为B的人，不指定名，就只会使用索引的第一列）

### 哈希索引
* 基于哈希表实现，只有精确匹配索引所有列的查询才有效。
* 存储引擎会对所有的索引列计算一个hash code，哈希索引将所有的hashcode存在索引中（Key），同时保存每个hashcode指向数据行的指针(Value)。（比如要寻找名为”小明“的人，会先计算出它的hashcode,然后在索引列中找到该hashcode，就可以找到其对应的列在哪一列）。
* Memory引擎支持显示的哈希索引，也支持B-Tree索引。
* InnoDB有”自适应哈希索引“的功能。InnoDB注意到某些索引值被使用的非常频繁的时候，会在内存中基于B-Tree索引之上再创建一个哈希索引。这是一个全自动的行为。
* 哈希索引不是按照索引值顺序存储的，所以无法用于排序。
* 哈希索引数据并不是支持部分索引列的查找，（A,B）建立哈希索引，不能仅仅查找A
* 哈希索引只支持等值比较查询，不支持范围查询。


### 全文索引
* 全文索引用于查找文本中的关键词。

### 前缀索引
* 对于TEXT或者很长的VARCHAR，必须使用前缀索引，仅仅索引开始的部分字符，

### 聚簇索引
* 一个表只能有一个主键（主键可以包含多个列），聚簇索引保证主键的值相近的行存储的物理位置也相近的。InnoDB表是基于聚簇索引建立的。当表有聚簇索引时，它的数据行实际上是存放在索引的叶子页中的。
* 一个表的聚簇索引也只能有一个，通常默认都是主键，设置了主键，系统默认就为你加上了聚簇索引。也可以拿字段作为聚簇索引，这就需要你在设置主键之前自己手动的先添加上唯一的聚簇索引，然后再设置主键。
* 如果你不指定主键，InnoDB会用一个具有唯一且非空值的索引来代替，如果不存在这样的索引，InnoDB会定义一个隐藏的主键，然后对其建立聚簇索引。


* 除了聚簇索引都被称为二级索引，二级索引包含主键，因此主键不宜过长
* InnoDB的二级索引的叶子节点中存储的不是行指针，而是主键数据。这意味着通过二级索引查找行，存储引擎需要：1、找到二级索引的叶子节点获取对应的主键值，2、根据这个主键值去聚簇索引中查找到对应的行。这里需要两次B-Tree查找而不是一次。


### 联合索引
1.需要加索引的字段，要在where条件中
2.如果where条件中是OR关系，加索引不起作用
3.符合最左原则
对列col1、列col2和列col3建一个联合索引

联合索引 test_col1_col2_col3 实际建立了(col1)、(col1,col2)、(col,col2,col3)三个索引。
```
SELECT * FROM test WHERE col1=“1” AND clo2=“2” AND clo4=“4”
```
上面这个查询语句执行时会依照最左前缀匹配原则，检索时会使用索引(col1,col2)进行数据匹配。

注意
索引的字段可以是任意顺序的，如：
```
SELECT * FROM test WHERE col1=“1” AND clo2=“2”
SELECT * FROM test WHERE col2=“2” AND clo1=“1”
```

## 索引失效的情况
* 1.如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因) 要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引
* 2.like查询以%开头，(like '%XX'或者like '%XX%')
* 3.对于联合索引，搜索的不包含第一部分


## 如何得知sql语句的效率?
* 1.慢查询日志
* 2.EXPLAIN 输出执行计划

## MySQL调优SQL语句，一般是怎么做的呢？
一般是先查看慢SQL日志，然后explain一下该查询语句，看是否索引失效或者是没建索引。

## 查出温度比前一天高的有哪些
一张表有（天（1/2/3/4........）、温度），查出温度比前一天高的有哪些
```
select  a.date  from  A a  left join A b on a.date = b.date-1 where a.tem>b.tem;
```

## Redis
Redis是使用c语言开发的一个高性能键值数据库。Redis可以通过一些键值类型来存储数据。

键值类型： 
* String字符类型:一般做一些复杂的计数功能的缓存。
* Hash :这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。
* list列表类型 :可以做简单的消息队列的功能
* set集合类型 :利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。
* sorted set有序集合类型 :可以做排行榜应用，取TOP N操作。

## redis和数据库双写一致性问题
首先。就是如果对数据有强一致性要求，不能放缓存。

## Redis持久化方式
### RDB
RDB是只记最终结果，在指定的时间间隔内将内存中的数据集快照写入磁盘。 也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中.

每次快照持久化都是将内存数据完整写入到磁盘一次，并不 是增量的只同步脏数据。如果数据量大的话，而且写操作比较多，必然会引起大量的磁盘io操作，可能会严重影响性能。
### AOF
AOF是记录所有执行的命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 当redis重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。

AOF 文件的体积通常要大于 RDB 文件的体积。因为RDB只用存最终结果，而AOF则要存所有的执行操作。 

AOF 的速度可能会慢于RDB，但是AOF更加安全， 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率， 但是， 因为RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下， 一旦发生故障停机， 你就可能会丢失好几分钟的数据。

## Redis的原子性
Redis是单线程的，所以其具有良好的原子性。

## 单线程的redis为什么这么快
* 1.纯内存操作
* 2.单线程操作，避免了频繁的上下文切换
* 3.采用了非阻塞I/O多路复用机制

## Redis相比memcached有哪些优势？
* 1.memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型
* 2.redis的速度比memcached快很多
* 3.redis可以持久化其数据

## Redis的过期策略以及内存淘汰机制
redis采用的是定期删除+惰性删除策略。
* 定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。
* 于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。

采用定期删除+惰性删除就没其他问题了么?

不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。

### 内存淘汰机制
* 1.noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。(不推荐)
* 2.allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（推荐使用）
* 3.allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。（不推荐）
* 4.volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。这种情况一般是把redis既当缓存，又做持久化存储的时候才用。（不推荐）
* 5.volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。（不推荐）
* 6.volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。（不推荐）

ps：如果没有设置expire的key, 不满足先决条件(prerequisites); 那么volatile-lru, volatile-random 和 volatile-ttl策略的行为,和noeviction(不删除) 基本上一致。

## MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？
redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略，将比较少使用的数据从缓存中删除。

## 如何应对缓存穿透和缓存雪崩问题
* 缓存穿透：即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。
解决方法：提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。

* 缓存雪崩：即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。
解决方法：给缓存的失效时间，加上一个随机值，避免集体失效。

## 如何解决redis的并发竞争key问题

这个问题大致就是，同时有多个子系统去set一个key。这个时候要注意什么呢？我提前百度了一下，发现答案基本都是推荐用redis事务机制。博主不推荐使用redis的事务机制。因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，redis的事务机制，十分鸡肋。


解决方法如下：
* 如果对这个key操作，不要求顺序，这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。
* 如果对这个key操作，要求顺序


假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC.

期望按照key1的value值按照 valueA–>valueB–>valueC的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。假设时间戳如下

```
系统A key 1 {valueA  3:00}
系统B key 1 {valueB  3:05}
系统C key 1 {valueC  3:10}
```

那么，假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。

其他方法，比如利用队列，将set方法变成串行访问也可以。

## Redis事务？
* 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。

* 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。


