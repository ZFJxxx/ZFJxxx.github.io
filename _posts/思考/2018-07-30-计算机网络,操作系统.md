---
layout: post
title:  计算机网络,操作系统总结
date:   2018-07-30 19:15:10
categories:  思考
tags: 面经
keywords: interview
description: 
---

## 计算机网络分为哪几层？

计算机网络如果是ISO模型的话，分为七层。TCP／IP协议簇模型的话，分为四层。

1.应用层，表示层，会话层（表示层和会话层从来没有独立实现过，都是和应用层在一起实现）
* 任务：提供用户和系统的接口：文件传输服务（FTP）、远程登录服务（Telnet）、电子邮件服务（SMTP）
* 功能：以笔记本举例，就是针对笔记本上的应用的，如邮件，web浏览器等都是所谓的应用。而应用层就是直接就是对这些应用提供服务的，提供服务的方式主要是通过各种协议。以web浏览器为例，http协议就是一种能为web浏览器服务的协议。
* 协议：FTP,SMTP,HTTP，DNS（基于UDP）


2.传输层：
* 任务：负责两个主机中进程之间的交互
* 功能：传输层为端到端连接提供可靠的传输服务；为端到端提供流量控制、差错控制等。
* 协议：TCP UDP

3.网络层  （路由器）
* 任务：将传输层传下来的报文封装成分组；选择适当的路由，使分组能够交付到目的主机
* 功能：通过路由选择算法，为报文或分组选择最适当的路径。网络层数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。
* 协议：ICMP,IP,ARP,RARP,IGMP

4.数据链路层  （交换机）
* 任务：将网络层传下来的IP数据报组装成帧。 
* 功能：帧是数据链路层的传送单位；如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。

5.物理层  （集线器HUB）
* 任务：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。 
* 功能：物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。

## tcp流量控制
* 1.利用滑动窗口实现流量控制 

设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节。超过了滑动窗口就不再能继续传输。

* 2.必须考虑传输速率 

可以用不同的机制来控制TCP报文段的发送时机。如： 
```
a. TCP维持一个变量，它等于最大报文段长度MSS。只要缓存中存放的数据达到MSS字节时，就组装成一个TCP报文段发送出去。 
b. TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。计时器期限到了，这时就把已有的缓存数据装入报文段(但长度不能超过MSS)发送出去。
```
## tcp拥塞控制

拥塞控制：防止过多的数据注入到网络中，这样可以防止网络中的路由器或链路过载。

拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷拥塞控制是一个全局性的过程。

几种拥塞控制方法 ：慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。

* 1.慢开始

主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。

通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。每经过一个传输轮次，拥塞窗口 cwnd 就**加倍**。

* 2.拥塞避免算法

为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个**慢开始门限**ssthresh状态变量。
```
当 cwnd < ssthresh 时，使用上述的慢开始算法。
当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。
```
让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。

无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。

![](http://p7lixluhf.bkt.clouddn.com/20170701115508163.png)

* 3.快重传和快恢复


一条TCP连接有时会因等待重传计时器的超时而空闲较长的时间，慢开始和拥塞避免无法很好的解决这类问题，因此提出了快重传和快恢复的拥塞控制方法。

a.TCP在收到3个同样的ACK的时候会启动快重传，立即重传丢失的报文段。（如果当发送端接收到三个重复的确认ACK时，则断定分组丢失，立即重传丢失的报文段，而不必等待重传计时器超时）


b.快恢复当发送端收到连续三个重复的 ACK 时，就将cwnd减半，然后把慢开始门限减半，这是为了预防网络发生拥塞。
```
快恢复做的两件事
1. cwnd = cwnd/2 
2. sshthresh = cwnd 
```

## 输入www.baidu.com后的流程

1.域名解析，浏览器会先去查看浏览器的DNS缓存中是否存在baidu的DNS解析，没有就回去查找操作系统自身的DNS缓存，如果还没有就会那么尝试读取hosts文件中是否存在IP映射。都不存在的话就会发起一个DNS系统调用，首先向运营商的DNS（电信或者Google）中查找是否存在缓存，如果不存在就运营商的DNS就会代我们向13台根域的DNS发起DNS解析请求，根域会发现这是一个顶级域为com域的一个域名，然后告诉运行商的DNS要去com域服务器查找，然后运营商的DNS向com域的IP地址发起请求，com域会返回baidu.com这个域的DNS地址，运营商的DNS又会向baidu.com这个域发起DNS请求，baidu.com域的DNS将www.baidu.com的IP地址返回给运营商DNS，然后运行商再将IP返回给客户端。

2.当然现在的大型网站都经过CDN加速，网站的DNS系统会最终将域名的解析权交给CDN专用DNS服务器，CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回用户。用户再去向全局负载均衡服务器发起URL访问请求，负载均衡服务器通过用户IP地址，以及用户请求的内容URL，塞选出一台离用户近，负载能力还Ok的CDN缓存服务器的IP地址返回给用户。

2.得到IP地址之后，客户端会通过和www.baidu.com的服务器的TCP的80端口通过三次握手建立TCP链接。建立链接之后就会发送一个GET类型的请求。

3.服务器会将baidu.com页面的Html代码返回给客户端，客户端拿到Html代码之后会解析渲染Html代码。

4.最后客户端和服务端四次挥手断开连接。


## GET POST的区别
GET请求的参数都放在URL里，所以参数是直接暴露的；而POST是通过request body 来传递参数的。
GET 的URL可以人肉手输，POST不能。
```
GET 请求可被缓存
GET 请求保留在浏览器历史记录中
GET 请求可被收藏为书签
GET 请求不应在处理敏感数据时使用
GET 请求有长度限制
GET 请求只应当用于取回数据
```
```
post 刷新请求会被重新提交
POST 请求不会被缓存
POST 请求不会保留在浏览器历史记录中
POST 不能被收藏为书签
POST 请求对数据长度没有要求
```
POST比GET安全一点点。。但是面对抓包工具还是没用，还是老实用HTTPS吧。

## Http报文
* 1.Http请求报文
```
1.请求行
2.请求头
3.请求体
```
![enter image description here](http://p7lixluhf.bkt.clouddn.com/http1.jpg)

* 2.Http响应报文
```
1.响应行
2.响应头
3.响应体
```
![enter image description here](http://p7lixluhf.bkt.clouddn.com/http2.jpg)

## https
https是在http上面套了一层ssl，用来实现安全连接。用到的密钥有对称密钥和非对称密钥。
基本上就是有数字证书，然后把对称密钥作为消息内容，通过非对称密钥来进行传输。之后双方的通信就通过对称密钥来进行解密就行了。


## Linux查看端口的指令
```
netstat -tunlp|grep 端口号
```
* -t (tcp)仅显示tcp相关选项
* -u (udp)仅显示udp相关选项
* -n 拒绝显示别名，能显示数字的全部转化成数字。
* -l 仅列出有在 Listen (监听) 的服務状态
* -p 显示建立相关链接的程序名

## forward和redirect区别
* forward是服务器内部的重定向，服务器直接访问目标地址的 url网址，把里面的东西读取出来，但是客户端并不知道，因此用forward的话，客户端浏览器的网址是不会发生变化的。
* redirect是客户端的重定向，是完全的跳转。即服务器返回的一个url给客户端浏览器,并返回3xx，然后客户端浏览器会重新发送一次请求，到新的url里面，因此浏览器中显示的url网址会发生变化。 

## 301和302的区别
* 301 redirect: 代表永久性转移(Permanently Moved) 301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；
* 302 redirect: 代表暂时性转移(Temporarily Moved) 302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。


## 进程和线程的区别是什么？

线程就是轻量级的进程。

进程是CPU分配资源的最小单元，线程是CPU调度的基本执行单元，一个进程可以包含多个线程。

进程有独立的地址空间，而线程只是一个进程中的不同执行路径。线程有自己的栈和局部变量。

因为进程启动的时候cpu需要给他分配资源，对系统压力比进程大，进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

## 进程之间的通信
进程间通讯可以通过socket，管道，信号，消息，共享内存等多种方式。
* 管道通信：管道的实质是一个缓冲区，写进程将数据以二进制字节流的形式将数据写入管道，读进程从管道中读数据。管道就是一个连接读进程和写进程的一个共享文件。注意管道一时刻只能单向传输，要双向传输需要两个管道。
* 共享内存：进程之间存在一块可直接访问的共享空间，多个进程都能够访问同一块内存。一般配合信号量作为同步手段控制对共享内存的读写操作。
* 信号：用于通知接受进程某件事件的发生，进程会捕捉到响应。
* 消息队列：发送进程将消息发送到接收进程的消息缓冲队列上，然后接收进程从消息缓冲队列中读取消息。
* socket：用于不同主机之间的进程通信。

## 线程之间的通信
* synchronized：这种方式，本质上就是“共享内存”式的通信。多个线程需要访问同一个共享变量，谁拿到了锁（获得了访问权限），谁就可以执行。
* wait/notify notifyAll
* 管道
