---
layout: post
title:  Interview Summary
date:   2018-07-25 19:15:10
categories:  思考
tags: 思考
keywords: interview
description: 
---

在求职路上的一些知识点总结，知识点比较杂乱。

## 封装、继承、多态
* 封装：封装性就是把类的属性和方法封装成一个独立单位，并尽可能隐蔽类（对象）的内部细节，只保留有限的对外接口使之与外部发生联系。
* 继承：子类继承父类的方法，使得子类具有父类的各种属性和方法，使得子类具有父类相同的行为。
* 多态：父类引用指向子类对象。比如：BaseClass p = new SubClass;p引用变量的编译时的类型BaseClass,而运行时的类型是SubClass，当运行时调用该引用变量的方法时，其方法总是表现出subClass方法的行为特性，对象的实例变量则不具备多态性，输出的是BaseClass类。

## 面向对象
## Object有哪些公用方法？
* 1.equals() 判断的是两个对象是否相等 
* 2.hashCode() 返回该对象的哈希码值。 
* 3.notify(),notifyall(),wait()都是用来对给定对象进行线程同步的
* 4.getClass() 返回该对象所属类的信息 
* 5.finalize() 当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。 
* 6.toString() 返回该对象的字符串表示。
* 7.clone() 进行对象拷贝 

## GET POST的区别

## Serializable 与 transient 关于序列化

**序列化 (Serialization)**：将对象的状态信息转换为可以存储或传输的形式（二进制字节流）的过程。

在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。

**注意：静态成员属于类级别的，所以不能序列化，序列化只是序列化了对象而已**

我们都知道一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。

这个类的有些属性需要序列化，而其他属性不需要被序列化；java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。

使用场景：为了安全起见，有时候我们不需要在网络间传输一些数据（如身份证号码，密码，银行卡号等）

## JVM内存模型
* 方法区：用于存储JVM加载的类信息、常量（常量池）、静态变量、以及编译器编译后的代码等数据。是线程共享的。
* 堆：堆的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都要在堆上分配。是线程共享的。
* 栈：创建一个线程，JVM就会为这个线程创建一个对应的Java栈，这个Java栈中又会含有多个栈帧（Frames）,这些栈帧是与每个方法关联起来的，每运行一个方法就创建一个栈帧，每个栈帧会含有一些局部变量、操作栈和方法返回值等信息。是线程私有的。
* 本地方法栈：和栈一样，只不过为Native方法服务，线程私有。
* PC寄存器：于保存当前正常执行的程序的内存地址，同时Java程序是多线程执行的，所以不能一直都按照线性执行下去，当有多个线程交叉执行时，被中断线程的程序当前执行到哪条的内存地址必须要保存下来。是线程私有的。

## 类加载机制
* 加载 ： 通过一个类的全限定名来获取其定义的二进制字节流；将二进制字节流代表的类结构转化存储到运行时数据区的方法区中；并在方法区内存中为其初始化一个java.lang.class类的对象，这样便可以通过该对象访问方法区中的这些数据。
* 验证：确保class文件的字节流中包含的信息符合当前虚拟机的要求。
* 准备：为类变量分配内存，并设置类变量的初始值。比如 static int a = 123; 先赋与a =0；
* 解析：将常量池中的符号引用换成直接引用。
* 初始化：虚主要是对类变量进行初始化，给a赋与123的值。（分为：声明类变量时指定初始值和使用静态初始化块为类变量指定初始值，顺序按先后）

## 类加载器
* 双亲委派模型
## GC

## 如何判断是否要对该对象进行GC

## 垃圾收集算法


## 常见运行时异常
* OutOfMemoryError
