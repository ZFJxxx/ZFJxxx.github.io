---
layout: post
title:  Interview Summary
date:   2018-07-25 19:15:10
categories:  思考
tags: 思考
keywords: interview
description: 
---

在求职路上的一些知识点总结。

## 封装、继承、多态
* 封装：封装性就是把类的属性和方法封装成一个独立单位，并尽可能隐蔽类（对象）的内部细节，只保留有限的对外接口使之与外部发生联系。
* 继承：子类继承父类的方法，使得子类具有父类的各种属性和方法，使得子类具有父类相同的行为。
* 多态：父类引用指向子类对象。比如：BaseClass p = new SubClass;p引用变量的编译时的类型BaseClass,而运行时的类型是SubClass，当运行时调用该引用变量的方法时，其方法总是表现出subClass方法的行为特性，对象的实例变量则不具备多态性，输出的是BaseClass类。

## 面向对象
面向对象就是将属性和方法都封装到一个class中；而面向过程是定义一堆属性、方法，在复杂的情况下就很难弄清楚。

## public protected default private

![](http://p7lixluhf.bkt.clouddn.com/public.jpg)


注意：default修饰方法和变量只能被同package的子类使用，protected修饰的方法和变量能被外包的子类使用。

## Object有哪些公用方法？
* 1.equals() 判断的是两个对象是否相等 
* 2.hashCode() 返回该对象的哈希码值。 
* 3.notify(),notifyall(),wait()都是用来对给定对象进行线程同步的
* 4.getClass() 返回该对象所属类的信息 
* 5.finalize() 当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。 
* 6.toString() 返回该对象的字符串表示。
* 7.clone() 进行对象拷贝 

## toString()和String.valueOf()的区别
当参数为空的时候.toString()方法就会报出空指针异常。

String.valueOf()：这个方法是静态的，直接通过String调用，在内部就是做了为空的判断的，所以就不会报出空指针异常。
```
public static String valueOf(Object obj){return (obj==null) ? "null" : obj.toString()};
```

## 为什么Object类里面会有wait和notify这两个方法
首先：
```
Object obj = newObject();
synchronized(obj){
　　　　try{　　
　　　　　　obj.wait();
　　　　　　}catch(Exception e){}
　　　　　　obj.notify();
　　}
```
注意：wait(),notify(),notifyAll()都必须使用在同步中，要对持有监视器(锁)的线程操作。所以要使用在同步中，因为只有同步 才具有锁。调用wait方法时会释放掉锁 
为什么这些操作线程的方法要定义在object类中呢？

简单说：因为synchronized中的这把锁可以是任意对象，所以任意对象都可以调用wait()和notify()；所以wait和notify属于Object。

专业说：因为这些方法在操作同步线程时，都必须要标识它们操作线程的锁，只有同一个锁上的被等待线程，可以被同一个锁上的notify唤醒，不可以对不同锁中的线程进行唤醒。 
也就是说，等待和唤醒必须是同一个锁。而锁可以是任意对象，所以可以被任意对象调用的方法是定义在object类中。

## wait()和sleep()的区别
sleep()来自Thread类，和wait()来自Object类

调用sleep()方法的过程中，线程不会释放对象锁。而 调用 wait()方法线程会释放对象锁。sleep()睡的时候只是抱着锁睡觉，会释放cpu时间片。wait()把时间片和资源的锁就全都释放出去了。

sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒。

而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备

## finalize()方法
finalize()是在java.lang.Object里定义的，也就是说每一个对象都有这么个方法。 
GC在销毁对象之前，会调用finalize()方法。完了之后再销毁对象。finalize()可以使该对象重新变成可达状态,从而使它不被回收
```
public void finalize(){
    ft= this;
}
```
## finally代码块必然执行吗？
```
try{              
    return 5;  
}catch(Exception e){  
    e.printStackTrace();  
}finally{  
    System.out.println("会执行嘛？");  
}  

//输出：
//会执行吗？
//5
```
* 1.不管有没有出现异常，finally块中代码都会执行；
* 2当try和catch中有return时，finally仍然会执行；
* 3。finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的；
* 4.finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。
* 5.System.exit(0); 退出虚拟机，自然不会执行finally
* 6.如果程序不执行try语句块，那么就不会执行finally


## 基本类型大小
![enter image description here](http://p7lixluhf.bkt.clouddn.com/20170928155212130.jpg)

int 范围 -2147483648~2147483647[-2^31~2^31-1]

## Serializable 与 transient 关于序列化

**序列化 (Serialization)**：将对象的状态信息转换为可以存储或传输的形式（二进制字节流）的过程。

在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。

**注意：静态成员属于类级别的，所以不能序列化，序列化只是序列化了对象而已**

我们都知道一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。

这个类的有些属性需要序列化，而其他属性不需要被序列化；java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。

使用场景：为了安全起见，有时候我们不需要在网络间传输一些数据（如身份证号码，密码，银行卡号等）

## JVM内存模型
* 方法区：用于存储JVM加载的类信息、常量（常量池）、静态变量、以及编译器编译后的代码等数据。是线程共享的。
* 堆：堆的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都要在堆上分配。是线程共享的。
* 栈：创建一个线程，JVM就会为这个线程创建一个对应的Java栈，这个Java栈中又会含有多个栈帧（Frames）,这些栈帧是与每个方法关联起来的，每运行一个方法就创建一个栈帧，每个栈帧会含有一些局部变量、操作栈和方法返回值等信息。是线程私有的。
* 本地方法栈：和栈一样，只不过为Native方法服务，线程私有。
* PC寄存器：用于指示当前线程所执行的字节码执行到了第几行，保存当前正常执行的程序的内存地址，同时Java程序是多线程执行的，所以不能一直都按照线性执行下去，当有多个线程交叉执行时，被中断线程的程序当前执行到哪条的内存地址必须要保存下来。是线程私有的。

## 类加载机制
* 加载 ：通过一个类的全限定名来获取其定义的二进制字节流；将二进制字节流代表的类结构转化存储到运行时数据区的方法区中；并在方法区内存中为其初始化一个java.lang.class类的对象，这样便可以通过该对象访问方法区中的这些数据。
* 验证：确保class文件的字节流中包含的信息符合当前虚拟机的要求。
* 准备：为类变量分配内存，并设置类变量的初始值。比如 static int a = 123; 先赋与a =0；
* 解析：将常量池中的符号引用换成直接引用。比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language来表示Language类的地址。直接引用可以是直接指向目标的指针，如果有了直接引用，那引用的目标必定已经被加载入内存中了。
* 初始化：虚主要是对类变量进行初始化，给a赋与123的值。（分为：声明类变量时指定初始值和使用静态初始化块为类变量指定初始值，顺序按先后）

## 类加载器
当JVM启动后，Bootstrap ClassLoader也随着启动，负责加载完核心类库后，并构造Extension ClassLoader和Application ClassLoader类加载器。

而程序在启动的时候，并不会一次性加载程序所要用的所有class文件，而是根据程序的需要，通过Java的类加载机制（ClassLoader）来动态加载某个class文件到内存当中的，从而只有class文件被载入到了内存之后，才能被其它class所引用。

* bootstrap classload：JVM的一部分，C++实现，启动类加载器，负责加载JDK中的核心类库。
* extension classload：扩展类加载器，负责加载Java的扩展类库，默认加载JAVA_HOME/jre/lib/ext/目下的所有jar。Java实现
* application classload：应用程序类类加载器，负责加载应用程序classpath目录下的所有jar和class文件。

**双亲委派模型：**

当一个ClassLoader实例需要加载某个类时，它会试图亲自搜索某个类之前，先把这个任务委托给它的父类加载器，这个过程是由上至下依次检查的，首先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader 进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类。如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的Class实例对象。

**双亲委托模型的重要用途是为了解决类载入过程中的安全性问题**

假设有一个开发者自己编写了一个名为Java.lang.Object的类，想借此欺骗JVM。现在他要使用自定义ClassLoader来加载自己编写的java.lang.Object类。然而幸运的是，双亲委托模型不会让他成功。因为JVM会优先在Bootstrap ClassLoader的路径下找到java.lang.Object类，并载入它。

**但是JVM在搜索类的时候，又是如何判定两个class是相同的呢？**

JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的。就算两个class是同一份class字节码，如果被两个不同的ClassLoader实例所加载，JVM也会认为它们是两个不同class。

## GC
* 对象优先在Eden区分配，对于大对象，无法放入survivor区的会被分配到老年代。
* 经过多次Young GC的对象（默认设置为15）就会进入老年代，Young GC之后都会有一部分对象分配到老年代。
* 老年代的Full GC一般比年轻代的Young GC频率低10倍。
* 每次Young GC时会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间，如果大于，改为直接进行一次Full GC，如果小于则查看HandlePromotionFailure设置看看是否允许担保失败，如果允许，那仍然进行Young GC，如果不允许，则也要改为进行一次Full GC。

## 如何判断是否要对该对象进行GC
* 引用计数法：当一个地方引用该对象的时候，设一个计数器+1，引用失效就-1；为0就是该对象不再被引用。该方法的缺陷是两个对象相互引用的时候，就算这两个对象都不再被访问，计数器却不为0，无法GC。
* 可达性分析算法：以GC Root为起始点，向下搜索，当一个对象到GC Root没有任何引用链相连时，那么这个对象是不可用的。

![enter image description here](http://p7lixluhf.bkt.clouddn.com/JVM-GC2.png)

## 四种引用
在Java中，虽然不需要程序员手动去管理对象的生命周期，但是如果希望某些对象具备一定的生命周期的话（比如内存不足时JVM就会自动回收某些对象从而避免OutOfMemory的错误）就需要用到软引用和弱引用了。

* 1.强引用：如果一个对象具有强引用，那么垃圾回收器绝对不会回收它，当内存不足时宁愿抛出 OOM 错误，使得程序异常停止。Object object = new Object(); 即是一个强引用。
* 2.软引用：如果一个对象只具有软引用，那么垃圾回收器在内存充足的时候不会回收它，而在内存不足时会回收这些对象。这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。
* 3.弱引用：如果一个对象只具有弱引用，那么垃圾回收器在扫描到该对象时，无论内存充足与否，都会回收该对象的内存。
* 4.虚引用：虚引用并不决定对象生命周期，如果一个对象只具有虚引用，那么它和没有任何引用一样，任何时候都可能被回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。

GC判断某个对象是否可被回收的依据是，是否有有效的引用指向该对象。如果没有有效引用指向该对象（基本意味着不存在访问该对象的方式），那么该对象就是可回收的。这里的“有效引用”并不包括**弱引用**。也就是说，虽然弱引用可以用来访问对象，但进行垃圾回收时弱引用并不会被考虑在内，仅有弱引用指向的对象仍然会被GC回收。

比如WeakHashMap 内部是通过弱引用来管理entry的，弱引用的特性对应到 WeakHashMap 上意味着什么呢？将一对key, value放入到 WeakHashMap 里并不能避免该key值被GC回收，除非在 WeakHashMap 之外还有对该key的强引用。

## 垃圾收集算法
* 1.标记-清除

标记出所有需要回收的对象，然后清除。这样效率不高，而且会产生大量不连续的内存碎片。
* 2.复制清除

将可用的内存分为大小相等的两部分，每当一块内存用完了，就将还存活的对象复制到另一块内存上去。
新生代大多采用何种算法，98%的对象都是“朝生夕死”的，所以将新生代按8：1：1分为Eden区和两个survivor区，每次对Eden区和一个survivor区进行Young GC,存活的放入另一个survivor区。如果多余10%的对象存活，survivor区无法存放Young GC存活下来的对象，就通过分配担保机制进入老年代。
* 3.标记-整理

这种算法用于老年代这种存活对象比较高的区域，先标记出需要清除的对象，然后让存活的对象向一端移动，然后直接清除掉其它的内存。
## G1垃圾回收器
* G1整体基于 标记-整理 算法实现的收集器，局部看是基于 复制算法。
* 利用多CPU缩短stop-the-world的时间。


Stop The World：从GC Roots进行可达性分析是，为了保持一致性，停顿所有的Java执行线程。就像时间冻结。


## Synchronize关键字为什么jdk1.5后效率提高了
Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。偏向所锁，轻量级锁都是乐观锁，重量级锁是悲观锁。

### 偏向锁
大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。偏向锁默认开启。

引入偏向锁的目的：在没有多线程竞争的情况下，尽量减少不必要的轻量级锁执行路径，轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只依赖一次CAS原子指令置换ThreadID，不过一旦出现多个线程竞争时必须撤销偏向锁，所以撤销偏向锁消耗的性能必须小于之前节省下来的CAS原子操作的性能消耗，不然就得不偿失了。

当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。

偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁，那么程序默认会进入轻量级锁状态。

### 轻量级锁
轻量级锁适用的场景是在线程交替获取某个锁执行同步代码块的场景，如果出现多个进程同时竞争同一个锁时，轻量级锁会膨胀成重量级锁。

轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。


### 自旋锁
这也是对锁的一种优化，线程的挂起和恢复会给系统的并发性带来压力；

共享数据的锁定状态一般只持续很短一段时间，为了这段时间区挂起恢复线程不值得；如果物理机由多核处理器，就能让多线程并行执行，我们就能让后面请求锁的线程“稍等”，但是并不挂起线程去等待，看持有锁的线程会不会很快的释放锁。

我们只需让线程执行一个忙循环（自旋），这就是所谓的自旋锁。

自旋锁避免了线程切换的开销，如果锁占用的时间短，就很好，反正锁被占用的时间长，自旋的线程只会白白消耗处理器资源。

![](http://p7lixluhf.bkt.clouddn.com/sychronized.PNG)
## Error和Exception区别
* Exception 和 Error 都是继承了 Throwable 类
* Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。
* Error 是指在正常情况下，不大可能出现的情况，绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如 OutOfMemoryError 之类，都是 Error 的子类。

## 常见运行时异常
* RuntimeException是一种Unchecked Exception，即表示编译器不会检查程序是否对RuntimeException作了处理，在程序中不必捕获RuntimException类型的异常，也不必在方法体声明抛出RuntimeException类。
* NullPointerException:空指针异常
* ArrayIndexOutOfBoundsException:数组下标越界异常
* ClassCastException:类型强制转换异常
* ArithmeticException:算术运算异常
* IllegalArgumentException：参数不正确

ps: 要么在方法体中声明抛出checked Exception，要么使用catch语句捕获checked Exception进行处理，不然不能通过编译。常用的Checked Exception有IOException、ClassNotFoundException等。

## 抽象工厂和工厂方法模式的区别
## Mybatis中#和$的区别
* #：会进行预编译，用于变量替换.可以防止sql注入等等问题
* $:实质上是字符串拼接,$方式一般用于传入数据库对象，比如这种group by 字段 ,order by 字段，表名，字段名等没法使用占位符的就需要使用${}

## forward和redirect区别
* forward是服务器内部的重定向，服务器直接访问目标地址的 url网址，把里面的东西读取出来，但是客户端并不知道，因此用forward的话，客户端浏览器的网址是不会发生变化的。
* redirect是客户端的重定向，是完全的跳转。即服务器返回的一个url给客户端浏览器,并返回3xx，然后客户端浏览器会重新发送一次请求，到新的url里面，因此浏览器中显示的url网址会发生变化。 

## 301和302的区别
* 301 redirect: 代表永久性转移(Permanently Moved) 301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；
* 302 redirect: 代表暂时性转移(Temporarily Moved) 302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。

## GET POST的区别
GET请求的参数都放在URL里，所以参数是直接暴露的；而POST是通过request body 来传递参数的。
GET 的URL可以人肉手输，POST不能。
```
GET 请求可被缓存
GET 请求保留在浏览器历史记录中
GET 请求可被收藏为书签
GET 请求不应在处理敏感数据时使用
GET 请求有长度限制
GET 请求只应当用于取回数据
```
```
post 刷新请求会被重新提交
POST 请求不会被缓存
POST 请求不会保留在浏览器历史记录中
POST 不能被收藏为书签
POST 请求对数据长度没有要求
```
POST比GET安全一点点。。但是面对抓包工具还是没用，还是老实用HTTPS吧。

## Http报文
* 1.Http请求报文
```
1.请求行
2.请求头
3.请求体
```
![enter image description here](http://p7lixluhf.bkt.clouddn.com/http1.jpg)

* 2.Http响应报文
```
1.响应行
2.响应头
3.响应体
```
![enter image description here](http://p7lixluhf.bkt.clouddn.com/http2.jpg)

## 三范式
* 第一范式：所有属性都是不可分割的原子值
* 第二范式：要求非主属性都要和码有完全依赖关系
* 第三范式：任何非主属性不依赖于其它非主属性

## 读写锁
* 读锁是共享的，多个用户可以同一时刻读取一个资源
* 写锁是排他的，同一时刻只有一个用户可以访问。

## ACID
原子性（Atomicity) 
事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。

一致性(Consistency) 
事务在完成时，必须使所有的数据都保持一致状态。只有在事物完成之后才能被所有使用者看见，保证了数据的完整性。例如从账户A转一笔钱到账户B上，如果账户A上的钱减少了，而账户B上的钱却没有增加，那么我们认为此时数据处于不一致的状态。

隔离性（Insulation） 
由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。也就是说一个事务操作的数据不会被其他实物看到和操作

持久性(Durability） 
事务完成之后，它对于系统的影响是永久性的。该修改即使出现致命的系统故障也将一直保持

## 隔离级别
* 读未提交：可以读到未提交事务的数据，也就是脏读，这个隔离级别性能最好，但是安全性低，很少使用。
* 读已提交:可避免发生脏读，但是会在一个事务内，读到其它事务提交的数据，导致执行两次同样的查询，读出不同的结果，也就是不可重复读。
* 可重复读：可避免脏读、不可重复读。MySQL默认隔离级别。但是会有幻读的问题：当读取某个范围内的数据时，另一事务在范围内插入了新数据，当前事务再次读取的时候会产生幻行。
* 串行化:最高隔离级别，强制事务串行执行，给每一行数据都加锁，很少使用，除非是低并发、需要保证数据一致性才使用。

## InnoDB 和 MyISAM
* **InnoDB**：MySQL的默认存储引擎；支持事务，对于InnoDB每一条SQL语言都默认封装成事务，自动提交；并且具有崩溃自动回复特性，默认实现的隔离级别是“可重复读”，InnoDB表是基于聚簇索引建立的（基于B+数结构）。
* **MyISAM**: 不支持事务和行级锁，只能对全表加锁，崩溃无法自动恢复。
* InnoDB不支持全文索引，MyISAM支持
* InnoDB支持外键，MyISAM不支持 

## 数据类型
* 整数类型：TINYINT,SMALLINT,MEDIUMINT,INT,BIGINT

分别占1个字节、2个字节、3个字节、4个字节、8个字节

* 浮点类型：FLOAT,DOUBLE

* 字符串类型：CHAR,VERCHAR，TEXT

CHAR存储长度不可变，长度一定的字符串，比如MD5后的密码，性别等。VERCHAR是可变长度的字符串，需要多用一个（字符串短于255）或者两个（字符串长于255）额外的字节存储字符串长度。

TEXT用于存储很大的字符串。
* 时间类型：DATE

