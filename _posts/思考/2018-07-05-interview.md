---
layout: post
title:  Interview Summary
date:   2018-07-25 19:15:10
categories:  思考
tags: 思考
keywords: interview
description: 
---

在求职路上的一些知识点总结。

## 封装、继承、多态
* 封装：封装性就是把类的属性和方法封装成一个独立单位，并尽可能隐蔽类（对象）的内部细节，只保留有限的对外接口使之与外部发生联系。
* 继承：子类继承父类的方法，使得子类具有父类的各种属性和方法，使得子类具有父类相同的行为。
* 多态：父类引用指向子类对象。比如：BaseClass p = new SubClass;p引用变量的编译时的类型BaseClass,而运行时的类型是SubClass，当运行时调用该引用变量的方法时，其方法总是表现出subClass方法的行为特性，对象的实例变量则不具备多态性，输出的是BaseClass类。

## 面向对象
面向对象就是将属性和方法都封装到一个class中；而面向过程是定义一堆属性、方法，在复制的情况下就很难弄清楚。

## Object有哪些公用方法？
* 1.equals() 判断的是两个对象是否相等 
* 2.hashCode() 返回该对象的哈希码值。 
* 3.notify(),notifyall(),wait()都是用来对给定对象进行线程同步的
* 4.getClass() 返回该对象所属类的信息 
* 5.finalize() 当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。 
* 6.toString() 返回该对象的字符串表示。
* 7.clone() 进行对象拷贝 



## Serializable 与 transient 关于序列化

**序列化 (Serialization)**：将对象的状态信息转换为可以存储或传输的形式（二进制字节流）的过程。

在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。

**注意：静态成员属于类级别的，所以不能序列化，序列化只是序列化了对象而已**

我们都知道一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。

这个类的有些属性需要序列化，而其他属性不需要被序列化；java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。

使用场景：为了安全起见，有时候我们不需要在网络间传输一些数据（如身份证号码，密码，银行卡号等）

## JVM内存模型
* 方法区：用于存储JVM加载的类信息、常量（常量池）、静态变量、以及编译器编译后的代码等数据。是线程共享的。
* 堆：堆的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都要在堆上分配。是线程共享的。
* 栈：创建一个线程，JVM就会为这个线程创建一个对应的Java栈，这个Java栈中又会含有多个栈帧（Frames）,这些栈帧是与每个方法关联起来的，每运行一个方法就创建一个栈帧，每个栈帧会含有一些局部变量、操作栈和方法返回值等信息。是线程私有的。
* 本地方法栈：和栈一样，只不过为Native方法服务，线程私有。
* PC寄存器：用于指示当前线程所执行的字节码执行到了第几行，保存当前正常执行的程序的内存地址，同时Java程序是多线程执行的，所以不能一直都按照线性执行下去，当有多个线程交叉执行时，被中断线程的程序当前执行到哪条的内存地址必须要保存下来。是线程私有的。

## 类加载机制
* 加载 ：通过一个类的全限定名来获取其定义的二进制字节流；将二进制字节流代表的类结构转化存储到运行时数据区的方法区中；并在方法区内存中为其初始化一个java.lang.class类的对象，这样便可以通过该对象访问方法区中的这些数据。
* 验证：确保class文件的字节流中包含的信息符合当前虚拟机的要求。
* 准备：为类变量分配内存，并设置类变量的初始值。比如 static int a = 123; 先赋与a =0；
* 解析：将常量池中的符号引用换成直接引用。比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language来表示Language类的地址。直接引用可以是直接指向目标的指针，如果有了直接引用，那引用的目标必定已经被加载入内存中了。
* 初始化：虚主要是对类变量进行初始化，给a赋与123的值。（分为：声明类变量时指定初始值和使用静态初始化块为类变量指定初始值，顺序按先后）

## 类加载器
当JVM启动后，Bootstrap ClassLoader也随着启动，负责加载完核心类库后，并构造Extension ClassLoader和Application ClassLoader类加载器。

而程序在启动的时候，并不会一次性加载程序所要用的所有class文件，而是根据程序的需要，通过Java的类加载机制（ClassLoader）来动态加载某个class文件到内存当中的，从而只有class文件被载入到了内存之后，才能被其它class所引用。

* bootstrap classload：JVM的一部分，C++实现，启动类加载器，负责加载JDK中的核心类库。
* extension classload：扩展类加载器，负责加载Java的扩展类库，默认加载JAVA_HOME/jre/lib/ext/目下的所有jar。Java实现
* application classload：应用程序类类加载器，负责加载应用程序classpath目录下的所有jar和class文件。

**双亲委派模型：**

当一个ClassLoader实例需要加载某个类时，它会试图亲自搜索某个类之前，先把这个任务委托给它的父类加载器，这个过程是由上至下依次检查的，首先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader 进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类。如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的Class实例对象。

**双亲委托模型的重要用途是为了解决类载入过程中的安全性问题**

假设有一个开发者自己编写了一个名为Java.lang.Object的类，想借此欺骗JVM。现在他要使用自定义ClassLoader来加载自己编写的java.lang.Object类。然而幸运的是，双亲委托模型不会让他成功。因为JVM会优先在Bootstrap ClassLoader的路径下找到java.lang.Object类，并载入它。

**但是JVM在搜索类的时候，又是如何判定两个class是相同的呢？**

JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的。就算两个class是同一份class字节码，如果被两个不同的ClassLoader实例所加载，JVM也会认为它们是两个不同class。

## GC
* 对象优先在Eden区分配，对于大对象，无法放入survivor区的会被分配到老年代。
* 经过多次Young GC的对象（默认设置为15）就会进入老年代，Young GC之后都会有一部分对象分配到老年代。
* 老年代的Full GC一般比年轻代的Young GC频率低10倍。
* 每次Young GC时会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间，如果大于，改为直接进行一次Full GC，如果小于则查看HandlePromotionFailure设置看看是否允许担保失败，如果允许，那仍然进行Young GC，如果不允许，则也要改为进行一次Full GC。

## 如何判断是否要对该对象进行GC
* 引用计数法：当一个地方引用该对象的时候，设一个计数器+1，引用失效就-1；为0就是该对象不再被引用。该方法的缺陷是两个对象相互引用的时候，就算这两个对象都不再被访问，计数器却不为0，无法GC。
* 可达性分析算法：以GC Root为起始点，向下搜索，当一个对象到GC Root没有任何引用链相连时，那么这个对象是不可用的。

![enter image description here](http://p7lixluhf.bkt.clouddn.com/JVM-GC2.png)

## 四种引用
在Java中，虽然不需要程序员手动去管理对象的生命周期，但是如果希望某些对象具备一定的生命周期的话（比如内存不足时JVM就会自动回收某些对象从而避免OutOfMemory的错误）就需要用到软引用和弱引用了。

* 1.强引用：如果一个对象具有强引用，那么垃圾回收器绝对不会回收它，当内存不足时宁愿抛出 OOM 错误，使得程序异常停止。Object object = new Object(); 即是一个强引用。
* 2.软引用：如果一个对象只具有软引用，那么垃圾回收器在内存充足的时候不会回收它，而在内存不足时会回收这些对象。这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。
* 3.弱引用：如果一个对象只具有弱引用，那么垃圾回收器在扫描到该对象时，无论内存充足与否，都会回收该对象的内存。
* 4.虚引用：虚引用并不决定对象生命周期，如果一个对象只具有虚引用，那么它和没有任何引用一样，任何时候都可能被回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。

GC判断某个对象是否可被回收的依据是，是否有有效的引用指向该对象。如果没有有效引用指向该对象（基本意味着不存在访问该对象的方式），那么该对象就是可回收的。这里的“有效引用”并不包括**弱引用**。也就是说，虽然弱引用可以用来访问对象，但进行垃圾回收时弱引用并不会被考虑在内，仅有弱引用指向的对象仍然会被GC回收。

比如WeakHashMap 内部是通过弱引用来管理entry的，弱引用的特性对应到 WeakHashMap 上意味着什么呢？将一对key, value放入到 WeakHashMap 里并不能避免该key值被GC回收，除非在 WeakHashMap 之外还有对该key的强引用。

## 垃圾收集算法
* 1.标记-清除

标记出所有需要回收的对象，然后清除。这样效率不高，而且会产生大量不连续的内存碎片。
* 2.复制清除

将可用的内存分为大小相等的两部分，每当一块内存用完了，就将还存活的对象复制到另一块内存上去。
新生代大多采用何种算法，98%的对象都是“朝生夕死”的，所以将新生代按8：1：1分为Eden区和两个survivor区，每次对Eden区和一个survivor区进行Young GC,存活的放入另一个survivor区。如果多余10%的对象存活，survivor区无法存放Young GC存活下来的对象，就通过分配担保机制进入老年代。
* 3.标记-整理

这种算法用于老年代这种存活对象比较高的区域，先标记出需要清除的对象，然后让存活的对象向一端移动，然后直接清除掉其它的内存。
## G1垃圾回收器
* G1整体基于 标记-整理 算法实现的收集器，局部看是基于 复制算法。
* 利用多CPU缩短stop-the-world的时间。

## 常见运行时异常
* ClassNotFoundException:指定类不存在
* NullPointerException:空指针异常
* ArrayIndexOutOfBoundsException:数组下标越界异常
* ClassCastException:类型强制转换异常
* ArithmeticException:算术运算异常
* IllegalArgumentException：参数不正确

## GET POST的区别
GET请求的参数都放在URL里，所以参数是直接暴露的；而POST是通过request body 来传递参数的。
GET 的URL可以人肉手输，POST不能。
```
GET 请求可被缓存
GET 请求保留在浏览器历史记录中
GET 请求可被收藏为书签
GET 请求不应在处理敏感数据时使用
GET 请求有长度限制
GET 请求只应当用于取回数据
```
```
post 刷新请求会被重新提交
POST 请求不会被缓存
POST 请求不会保留在浏览器历史记录中
POST 不能被收藏为书签
POST 请求对数据长度没有要求
```
POST比GET安全一点点。。但是面对抓包工具还是没用，还是老实用HTTPS吧。

## Http报文
* 1.Http请求报文
```
1.请求行
2.请求头
3.请求体
```
![enter image description here](http://p7lixluhf.bkt.clouddn.com/http1.jpg）

* 2.Http响应报文
```
1.响应行
2.响应头
3.响应体
```
![enter image description here](http://p7lixluhf.bkt.clouddn.com/http2.jpg）
## Https
