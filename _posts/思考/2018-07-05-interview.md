---
layout: post
title:  Interview Summary
date:   2018-07-25 19:15:10
categories:  思考
tags: 思考
keywords: interview
description: 
---

在求职路上的一些知识点总结。

## 封装、继承、多态
* 封装：封装性就是把类的属性和方法封装成一个独立单位，并尽可能隐蔽类（对象）的内部细节，只保留有限的对外接口使之与外部发生联系。
* 继承：子类继承父类的方法，使得子类具有父类的各种属性和方法，使得子类具有父类相同的行为。
* 多态：父类引用指向子类对象。比如：BaseClass p = new SubClass;p引用变量的编译时的类型BaseClass,而运行时的类型是SubClass，当运行时调用该引用变量的方法时，其方法总是表现出subClass方法的行为特性，对象的实例变量则不具备多态性，输出的是BaseClass类。

## 面向对象
面向对象就是将属性和方法都封装到一个class中；而面向过程是定义一堆属性、方法，在复制的情况下就很难弄清楚。

## public protected deflut private

![](http://p7lixluhf.bkt.clouddn.com/public.jpg)


注意：defult修饰方法和变量只能被同package的子类使用，protected修饰的方法和变量能被外包的子类使用。

## Object有哪些公用方法？
* 1.equals() 判断的是两个对象是否相等 
* 2.hashCode() 返回该对象的哈希码值。 
* 3.notify(),notifyall(),wait()都是用来对给定对象进行线程同步的
* 4.getClass() 返回该对象所属类的信息 
* 5.finalize() 当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。 
* 6.toString() 返回该对象的字符串表示。
* 7.clone() 进行对象拷贝 

## 为什么Object类里面会有wait和notify这两个方法
首先：
```
Object obj = newObject();
synchronized(obj){
　　　　try{　　
　　　　　　obj.wait();
　　　　　　}catch(Exception e){}
　　　　　　obj.notify();
　　}
```
注意：wait(),notify(),notifyAll()都必须使用在同步中，要对持有监视器(锁)的线程操作。所以要使用在同步中，因为只有同步 才具有锁。调用wait方法时会释放掉锁 
为什么这些操作线程的方法要定义在object类中呢？

简单说：因为synchronized中的这把锁可以是任意对象，所以任意对象都可以调用wait()和notify()；所以wait和notify属于Object。

专业说：因为这些方法在操作同步线程时，都必须要标识它们操作线程的锁，只有同一个锁上的被等待线程，可以被同一个锁上的notify唤醒，不可以对不同锁中的线程进行唤醒。 
也就是说，等待和唤醒必须是同一个锁。而锁可以是任意对象，所以可以被任意对象调用的方法是定义在object类中。

## wait()和sleep()的区别
sleep()来自Thread类，和wait()来自Object类

调用sleep()方法的过程中，线程不会释放对象锁。而 调用 wait()方法线程会释放对象锁。sleep()睡的时候只是抱着锁睡觉，会释放cpu时间片。wait()把时间片和资源的锁就全都释放出去了。

sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒。wait()需要notify唤醒.

## finalize()方法
finalize()是在java.lang.Object里定义的，也就是说每一个对象都有这么个方法。 
GC在销毁对象之前，会调用finalize()方法。完了之后再销毁对象。finalize()可以使该对象重新变成可达状态,从而使它不被回收
```
public void finalize(){
    ft= this;
}
```

## 基本类型大小
![enter image description here](http://p7lixluhf.bkt.clouddn.com/20170928155212130.jpg)

int 范围 -2147483648~2147483647[-2^31~2^31-1]

## Serializable 与 transient 关于序列化

**序列化 (Serialization)**：将对象的状态信息转换为可以存储或传输的形式（二进制字节流）的过程。

在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。

**注意：静态成员属于类级别的，所以不能序列化，序列化只是序列化了对象而已**

我们都知道一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。

这个类的有些属性需要序列化，而其他属性不需要被序列化；java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。

使用场景：为了安全起见，有时候我们不需要在网络间传输一些数据（如身份证号码，密码，银行卡号等）

## JVM内存模型
* 方法区：用于存储JVM加载的类信息、常量（常量池）、静态变量、以及编译器编译后的代码等数据。是线程共享的。
* 堆：堆的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都要在堆上分配。是线程共享的。
* 栈：创建一个线程，JVM就会为这个线程创建一个对应的Java栈，这个Java栈中又会含有多个栈帧（Frames）,这些栈帧是与每个方法关联起来的，每运行一个方法就创建一个栈帧，每个栈帧会含有一些局部变量、操作栈和方法返回值等信息。是线程私有的。
* 本地方法栈：和栈一样，只不过为Native方法服务，线程私有。
* PC寄存器：用于指示当前线程所执行的字节码执行到了第几行，保存当前正常执行的程序的内存地址，同时Java程序是多线程执行的，所以不能一直都按照线性执行下去，当有多个线程交叉执行时，被中断线程的程序当前执行到哪条的内存地址必须要保存下来。是线程私有的。

## 类加载机制
* 加载 ：通过一个类的全限定名来获取其定义的二进制字节流；将二进制字节流代表的类结构转化存储到运行时数据区的方法区中；并在方法区内存中为其初始化一个java.lang.class类的对象，这样便可以通过该对象访问方法区中的这些数据。
* 验证：确保class文件的字节流中包含的信息符合当前虚拟机的要求。
* 准备：为类变量分配内存，并设置类变量的初始值。比如 static int a = 123; 先赋与a =0；
* 解析：将常量池中的符号引用换成直接引用。比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language来表示Language类的地址。直接引用可以是直接指向目标的指针，如果有了直接引用，那引用的目标必定已经被加载入内存中了。
* 初始化：虚主要是对类变量进行初始化，给a赋与123的值。（分为：声明类变量时指定初始值和使用静态初始化块为类变量指定初始值，顺序按先后）

## 类加载器
当JVM启动后，Bootstrap ClassLoader也随着启动，负责加载完核心类库后，并构造Extension ClassLoader和Application ClassLoader类加载器。

而程序在启动的时候，并不会一次性加载程序所要用的所有class文件，而是根据程序的需要，通过Java的类加载机制（ClassLoader）来动态加载某个class文件到内存当中的，从而只有class文件被载入到了内存之后，才能被其它class所引用。

* bootstrap classload：JVM的一部分，C++实现，启动类加载器，负责加载JDK中的核心类库。
* extension classload：扩展类加载器，负责加载Java的扩展类库，默认加载JAVA_HOME/jre/lib/ext/目下的所有jar。Java实现
* application classload：应用程序类类加载器，负责加载应用程序classpath目录下的所有jar和class文件。

**双亲委派模型：**

当一个ClassLoader实例需要加载某个类时，它会试图亲自搜索某个类之前，先把这个任务委托给它的父类加载器，这个过程是由上至下依次检查的，首先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader 进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类。如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的Class实例对象。

**双亲委托模型的重要用途是为了解决类载入过程中的安全性问题**

假设有一个开发者自己编写了一个名为Java.lang.Object的类，想借此欺骗JVM。现在他要使用自定义ClassLoader来加载自己编写的java.lang.Object类。然而幸运的是，双亲委托模型不会让他成功。因为JVM会优先在Bootstrap ClassLoader的路径下找到java.lang.Object类，并载入它。

**但是JVM在搜索类的时候，又是如何判定两个class是相同的呢？**

JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的。就算两个class是同一份class字节码，如果被两个不同的ClassLoader实例所加载，JVM也会认为它们是两个不同class。

## GC
* 对象优先在Eden区分配，对于大对象，无法放入survivor区的会被分配到老年代。
* 经过多次Young GC的对象（默认设置为15）就会进入老年代，Young GC之后都会有一部分对象分配到老年代。
* 老年代的Full GC一般比年轻代的Young GC频率低10倍。
* 每次Young GC时会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间，如果大于，改为直接进行一次Full GC，如果小于则查看HandlePromotionFailure设置看看是否允许担保失败，如果允许，那仍然进行Young GC，如果不允许，则也要改为进行一次Full GC。

## 如何判断是否要对该对象进行GC
* 引用计数法：当一个地方引用该对象的时候，设一个计数器+1，引用失效就-1；为0就是该对象不再被引用。该方法的缺陷是两个对象相互引用的时候，就算这两个对象都不再被访问，计数器却不为0，无法GC。
* 可达性分析算法：以GC Root为起始点，向下搜索，当一个对象到GC Root没有任何引用链相连时，那么这个对象是不可用的。

![enter image description here](http://p7lixluhf.bkt.clouddn.com/JVM-GC2.png)

## 四种引用
在Java中，虽然不需要程序员手动去管理对象的生命周期，但是如果希望某些对象具备一定的生命周期的话（比如内存不足时JVM就会自动回收某些对象从而避免OutOfMemory的错误）就需要用到软引用和弱引用了。

* 1.强引用：如果一个对象具有强引用，那么垃圾回收器绝对不会回收它，当内存不足时宁愿抛出 OOM 错误，使得程序异常停止。Object object = new Object(); 即是一个强引用。
* 2.软引用：如果一个对象只具有软引用，那么垃圾回收器在内存充足的时候不会回收它，而在内存不足时会回收这些对象。这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。
* 3.弱引用：如果一个对象只具有弱引用，那么垃圾回收器在扫描到该对象时，无论内存充足与否，都会回收该对象的内存。
* 4.虚引用：虚引用并不决定对象生命周期，如果一个对象只具有虚引用，那么它和没有任何引用一样，任何时候都可能被回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。

GC判断某个对象是否可被回收的依据是，是否有有效的引用指向该对象。如果没有有效引用指向该对象（基本意味着不存在访问该对象的方式），那么该对象就是可回收的。这里的“有效引用”并不包括**弱引用**。也就是说，虽然弱引用可以用来访问对象，但进行垃圾回收时弱引用并不会被考虑在内，仅有弱引用指向的对象仍然会被GC回收。

比如WeakHashMap 内部是通过弱引用来管理entry的，弱引用的特性对应到 WeakHashMap 上意味着什么呢？将一对key, value放入到 WeakHashMap 里并不能避免该key值被GC回收，除非在 WeakHashMap 之外还有对该key的强引用。

## 垃圾收集算法
* 1.标记-清除

标记出所有需要回收的对象，然后清除。这样效率不高，而且会产生大量不连续的内存碎片。
* 2.复制清除

将可用的内存分为大小相等的两部分，每当一块内存用完了，就将还存活的对象复制到另一块内存上去。
新生代大多采用何种算法，98%的对象都是“朝生夕死”的，所以将新生代按8：1：1分为Eden区和两个survivor区，每次对Eden区和一个survivor区进行Young GC,存活的放入另一个survivor区。如果多余10%的对象存活，survivor区无法存放Young GC存活下来的对象，就通过分配担保机制进入老年代。
* 3.标记-整理

这种算法用于老年代这种存活对象比较高的区域，先标记出需要清除的对象，然后让存活的对象向一端移动，然后直接清除掉其它的内存。
## G1垃圾回收器
* G1整体基于 标记-整理 算法实现的收集器，局部看是基于 复制算法。
* 利用多CPU缩短stop-the-world的时间。


Stop The World：从GC Roots进行可达性分析是，为了保持一致性，停顿所有的Java执行线程。就像时间冻结
## 自旋锁
线程的挂起和回复会给系统的并发性带来压力；

共享数据的锁定状态一般只持续很短一段时间，为了这段时间区挂起恢复线程不值得；如果物理机由多核处理器，就能让多线程并行执行，我们就能让后面请求锁的线程“稍等”，但是并不挂起线程去等待，看持有锁的线程会不会很快的释放锁。

我们只需让线程执行一个忙循环（自旋），这就是所谓的自旋锁。

自旋锁避免了线程切换的开销，如果锁占用的时间短，就很好，反正锁被占用的时间长，自旋的线程只会白白消耗处理器资源。

## 常见运行时异常
* ClassNotFoundException:指定类不存在
* NullPointerException:空指针异常
* ArrayIndexOutOfBoundsException:数组下标越界异常
* ClassCastException:类型强制转换异常
* ArithmeticException:算术运算异常
* IllegalArgumentException：参数不正确

## GET POST的区别
GET请求的参数都放在URL里，所以参数是直接暴露的；而POST是通过request body 来传递参数的。
GET 的URL可以人肉手输，POST不能。
```
GET 请求可被缓存
GET 请求保留在浏览器历史记录中
GET 请求可被收藏为书签
GET 请求不应在处理敏感数据时使用
GET 请求有长度限制
GET 请求只应当用于取回数据
```
```
post 刷新请求会被重新提交
POST 请求不会被缓存
POST 请求不会保留在浏览器历史记录中
POST 不能被收藏为书签
POST 请求对数据长度没有要求
```
POST比GET安全一点点。。但是面对抓包工具还是没用，还是老实用HTTPS吧。

## Http报文
* 1.Http请求报文
```
1.请求行
2.请求头
3.请求体
```
![enter image description here](http://p7lixluhf.bkt.clouddn.com/http1.jpg)

* 2.Http响应报文
```
1.响应行
2.响应头
3.响应体
```
![enter image description here](http://p7lixluhf.bkt.clouddn.com/http2.jpg)

## 三范式
* 第一范式：所有属性都是不可分割的原子值
* 第二范式：要求非主属性都要和码有完全依赖关系
* 第三范式：任何非主属性不依赖于其它非主属性

## 读写锁
* 读锁是共享的，多个用户可以同一时刻读取一个资源
* 写锁是排他的，同一时刻只有一个用户可以访问。

## ACID
原子性（Atomicity) 
事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。

一致性(Consistency) 
事务在完成时，必须使所有的数据都保持一致状态。只有在事物完成之后才能被所有使用者看见，保证了数据的完整性。例如从账户A转一笔钱到账户B上，如果账户A上的钱减少了，而账户B上的钱却没有增加，那么我们认为此时数据处于不一致的状态。

隔离性（Insulation） 
由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。也就是说一个事务操作的数据不会被其他实物看到和操作

持久性(Durability） 
事务完成之后，它对于系统的影响是永久性的。该修改即使出现致命的系统故障也将一直保持

## 隔离级别
* 读未提交：可以读到未提交事务的数据，也就是脏读，这个隔离级别性能最好，但是安全性低，很少使用。
* 读已提交:可避免发生脏读，但是会在一个事务内，读到其它事务提交的数据，导致执行两次同样的查询，读出不同的结果，也就是不可重复读。
* 可重复读：可避免脏读、不可重复读。MySQL默认隔离级别。但是会有幻读的问题：当读取某个范围内的数据时，另一事务在范围内插入了新数据，当前事务再次读取的时候会产生幻行。
* 串行化:最高隔离级别，强制事务串行执行，给每一行数据都加锁，很少使用，除非是低并发、需要保证数据一致性才使用。

## InnoDB 和 MyISAM
* **InnoDB**：MySQL的默认存储引擎；支持事务，对于InnoDB每一条SQL语言都默认封装成事务，自动提交；并且具有崩溃自动回复特性，默认实现的隔离级别是“可重复读”，InnoDB表是基于聚簇索引建立的（基于B+数结构）。
* **MyISAM**: 不支持事务和行级锁，只能对全表加锁，崩溃无法自动恢复。
* InnoDB不支持全文索引，MyISAM支持
* InnoDB支持外键，MyISAM不支持 

## 数据类型
* 整数类型：TINYINT,SMALLINT,MEDIUMINT,INT,BIGINT

分别占1个字节、2个字节、3个字节、4个字节、8个字节

* 浮点类型：FLOAT,DOUBLE

* 字符串类型：CHAR,VERCHAR，TEXT

CHAR存储长度不可变，长度一定的字符串，比如MD5后的密码，性别等。VERCHAR是可变长度的字符串，需要多用一个（字符串短于255）或者两个（字符串长于255）额外的字节存储字符串长度。

TEXT用于存储很大的字符串。
* 时间类型：DATE

