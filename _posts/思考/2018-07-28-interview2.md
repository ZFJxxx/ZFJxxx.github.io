---
layout: post
title:  Interview Summary(DataBase)
date:   2018-07-28 19:15:10
categories:  思考
tags: 思考
keywords: interview
description: 
---

## 三范式
* 第一范式：所有属性都是不可分割的原子值
* 第二范式：要求非主属性完全依赖于主属性。所谓完全依赖是指不能存在仅依赖主关属性一部分的属性
* 第三范式：任何非主属性不依赖于其它非主属性

## 读写锁
* 读锁是共享的，多个用户可以同一时刻读取一个资源
* 写锁是排他的，同一时刻只有一个用户可以访问。

## ACID
原子性（Atomicity) 
事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。

一致性(Consistency) 
事务在完成时，必须使所有的数据都保持一致状态。只有在事物完成之后才能被所有使用者看见，保证了数据的完整性。例如从账户A转一笔钱到账户B上，如果账户A上的钱减少了，而账户B上的钱却没有增加，那么我们认为此时数据处于不一致的状态。

隔离性（Insulation） 
由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。也就是说一个事务操作的数据不会被其他实物看到和操作

持久性(Durability） 
事务完成之后，它对于系统的影响是永久性的。该修改即使出现致命的系统故障也将一直保持

## 隔离级别
* 读未提交：可以读到未提交事务的数据，也就是脏读，这个隔离级别性能最好，但是安全性低，很少使用。
* 读已提交:可避免发生脏读，但是会在一个事务内，读到其它事务提交的数据，导致执行两次同样的查询，读出不同的结果，也就是不可重复读。
* 可重复读：可避免脏读、不可重复读。MySQL默认隔离级别。但是会有幻读的问题：当读取某个范围内的数据时，另一事务在范围内插入了新数据，当前事务再次读取的时候会产生幻行。
* 串行化:最高隔离级别，强制事务串行执行，给每一行数据都加锁，很少使用，除非是低并发、需要保证数据一致性才使用。

## InnoDB 和 MyISAM
* **InnoDB**：MySQL的默认存储引擎；支持事务，对于InnoDB每一条SQL语言都默认封装成事务，自动提交；并且具有崩溃自动回复特性，默认实现的隔离级别是“可重复读”，InnoDB表是基于聚簇索引建立的（基于B+数结构）。
* **MyISAM**: 不支持事务和行级锁，只能对全表加锁，崩溃无法自动恢复。
* InnoDB不支持全文索引，MyISAM支持 （5.6InnoDB已经支持全文索引）
* InnoDB支持外键，MyISAM不支持 
* MyISAM锁的粒度是表级，而InnoDB支持行级锁定。
* InnoDB是事务安全型的，默认开启自动提交，MyISAM不支持事务
* MyISAM是按照数据插入的顺序存储在磁盘上,将索引存储到内存中，而数据直接存到硬盘；InnoDB是根据主键将数据存在B+树的叶子节点中，数据和索引存放在一起，都在内存中，然后再存到硬盘

![](http://p7lixluhf.bkt.clouddn.com/MySQLindex.PNG)

## 数据类型
* 整数类型：TINYINT,SMALLINT,MEDIUMINT,INT,BIGINT

分别占1个字节、2个字节、3个字节、4个字节、8个字节

* 浮点类型：FLOAT,DOUBLE

* 字符串类型：CHAR,VERCHAR，TEXT

CHAR存储长度不可变，长度一定的字符串，比如MD5后的密码，性别等。VERCHAR是可变长度的字符串，需要多用一个（字符串短于255）或者两个（字符串长于255）额外的字节存储字符串长度。

TEXT用于存储很大的字符串。
* 时间类型：DATE

## 索引
索引的优点：
* 1.加快查询速度，大大减少服务器需要扫描的数据量
* 2.将随机IO变成了顺序IO
* 3.索引对于InnoDB（对索引支持行级锁）非常重要，因为它可以让查询锁更少的元组。

索引的缺点：
* 1.虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存索引文件
* 2.建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。
* 3.如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。
* 4.对于非常小的表，大部分情况下简单的全表扫描更高效；

### B+Tree索引
* B+Tree索引对索引列时顺序组织存储的，所以很适合查找范围数据。B+Tree所有索引数据都在叶子结点上，并且增加了顺序访问指针,每个叶子节点都有指向相邻叶子节点的指针。这样做是为了提高区间查询效率，例如查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。
* B-Tree索引适用于全键值，键值范围或者键前缀查找（前缀只能从左前缀开始）
* 数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。
* 除了按值查找之外，B-Tree索引还可以用于查询中的ORDER BY操作。
* 如果不是按照索引最左列开始查找，则无法使用索引（比如名字以x结尾的人）
* 不能跳过索引中的列。（比如以姓，名，生日三个键为索引，不能查找姓为A，生日为B的人，不指定名，就只会使用索引的第一列）

### 哈希索引
* 基于哈希表实现，只有精确匹配索引所有列的查询才有效。
* 存储引擎会对所有的索引列计算一个hash code，哈希索引将所有的hashcode存在索引中，同时保存每个hashcode指向数据行的指针。（比如要寻找名为”小明“的人，会先计算出它的hashcode,然后在索引列中找到该hashcode，就可以找到其对应的列在哪一列）。
* Memory引擎支持显示的哈希索引，也支持B-Tree索引。
* InnoDB有”自适应哈希索引“的功能。InnoDB注意到某些索引值被使用的非常频繁的时候，会在内存中基于B-Tree索引之上再创建一个哈希索引。这是一个全自动的行为。
* 哈希索引不是按照索引值顺序存储的，所以无法用于排序。
* 哈希索引数据并不是支持部分索引列的查找，应为要用全部列来计算hashcode。
* 哈希索引只支持等值比较查询，不支持范围查询。

### 给你1亿个URL，如何快速查找出指定的URL（创建自定义哈希索引）
哈希索引的应用，可以对URL进行MD5操作（这个操作就相当于为每个URL生成一个hashcode），再使用hash就能快速查找到指定URL。（避免冲突问题，最好在WHERE后面加入哈希值比较和对应列值比较）

### 全文索引
* 全文索引用于查找文本中的关键词。

### 前缀索引
* 对于TEXT或者很长的VARCHAR，必须使用前缀索引，仅仅索引开始的部分字符，

### 聚簇索引
* InnoDB表是基于聚簇索引建立的，当表有聚簇索引时，它的数据行实际上是存放在索引的叶子页中的。
* 一个表的聚簇索引也只能有一个，通常默认都是主键，设置了主键，系统默认就为你加上了聚簇索引，当然也可以拿主键作为聚簇索引，我需要用其他字段作为索引，当然这也是可以的，这就需要你在设置主键之前自己手动的先添加上唯一的聚簇索引，然后再设置主键。
* 如果你不指定主键，InnoDB会用一个具有唯一且非空值的索引来代替。
* 如果不存在这样的索引，InnoDB会定义一个隐藏的主键，然后对其建立聚簇索引。
* 聚簇索引保证关键字的值相近的元组存储的物理位置也相近
* 除了聚簇索引都被称为二级索引，二级索引包含主键，因此主键不宜过长
* InnoDB的二级索引的叶子节点中存储的不是行指针，而是主键数据。这意味着通过二级索引查找行，存储引擎需要：1、找到二级索引的叶子节点获取对应的主键值，2、根据这个主键值去聚簇索引中查找到对应的行。这里需要两次B-Tree查找而不是一次。


### 联合索引
即一个索包含多个列

举一个例子，大学选认课老师，需要创建一个关系对应表，有2个字段,student_id 和 teacher_id，想要查询某个老师和某个学生是否存在师生关系。一个学生会选几十个老师，一个老师会带几百个学生

如果只为student_id建立索引的情况下，经过索引会选出几十条记录，然后在内存中where一下，去除其余的老师。

相反如果只为teacher_id建立索引，经过索引会选出几百条记录，然后在内存中where一下，去除其余的学生。

两种情况都不是最优的，这个时候使用联合索引最合适，通过索引直接找到对应记录。

建立这样的组合索引，其实是相当于分别建立了下面两组组合索引：
```
student_id  teacher_id
student_id
```

## MySQL建立索引类型

* 1.普通索引:普通索引（由关键字KEY或INDEX定义的索引）的唯一任务是加快对数据的访问速度。
* 2.唯一索引:唯一索引它与前面的普通索引类似，不同的就是：普通索引允许被索引的数据列包含重复的值。而唯一索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。
* 3.主键索引:它是一种特殊的唯一索引，不允许有空值。一个表只能有一个主键。一般是在建表的时候同时创建主键索引
