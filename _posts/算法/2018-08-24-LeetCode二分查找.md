---
layout: post
title:  LeetCode二分查找
date:   2018-08-24 11:15:10
categories: 算法
tags: LeetCode
keywords: LeetCode
description: 
---
首先：

非递归
```
public int binarySearch(int[] nums, int target) {
    int low = 0, high = nums.length-1;
    while (low <= high) { 
        int mid = low + (high - low) / 2;
        if (nums[mid] < target) { low = mid + 1; }
        if (nums[mid] > target) { high = mid - 1; }
        if (nums[mid] == target) { return mid; }
    }
    return low;               //返回值完全不需要纠结，直接返回低位 low
}
```
递归
```
public int binarySearchRecur(int[] nums, int target, int low, int high) {
    if (low > high) { return low; } //base case
    int mid = low + (high - low) / 2;
    if (nums[mid] > target) {
        return binarySearchRecur(nums,target,low,mid-1);
    }  else if (nums[mid] < target) {
        return binarySearchRecur(nums,target,mid+1,high);
    } else {
        return mid;
    }
}
```

## 33. Search in Rotated Sorted Array
**给你一个旋转的有序数组，找出target值**

**比如[0,1,2,4,5,6,7] -> 旋转 [4,5,6,7,0,1,2]**
```
Example 1:

Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
Example 2:

Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
```
思路：
```
数组可以分为两个增序数组

当进行二元搜索时，我们可以判断哪个部分是有序的以及目标是否在该范围内，如果是 ，继续搜索那一半，如果没有继续在另一半。
```
```
public class Solution {
    public int search(int[] nums, int target) {
        int start = 0;
        int end = nums.length - 1;
        while (start <= end){
            int mid = (start + end) / 2;
            if (nums[mid] == target)
                return mid;
        
            if (nums[start] <= nums[mid]){                         //mid处于第一个增序      
                 if (target < nums[mid] && target >= nums[start])  //target在start-mid之间
                    end = mid - 1;
                 else
                    start = mid + 1;
            } 
        
            if (nums[mid] <= nums[end]){                       //mid处于第二个增序
                if (target > nums[mid] && target <= nums[end]) //target在mid - end之间
                    start = mid + 1;
                 else
                    end = mid - 1;
            }
        }
        return -1;
    }
}
```


## 35. Search Insert Position
**给你一个排好序的数组和一个target，如果在数组中找到这个数，就返回下标；如果没找到，就返回如果将这个数有序插入进数组对应的下标**
```
Example 1:

Input: [1,3,5,6], 5
Output: 2
Example 2:

Input: [1,3,5,6], 2
Output: 1
Example 3:

Input: [1,3,5,6], 7
Output: 4
Example 4:

Input: [1,3,5,6], 0
Output: 0
```
```
class Solution {
    public int searchInsert(int[] nums, int target) {
        int low = 0;
        int high = nums.length-1;
        while(low<=high){
            int mid = low + (high - low)/2;
            if(nums[mid] == target) 
                return mid;
            else if(nums[mid] > target) 
                high = mid-1;
            else 
                low = mid+1;
        }
        return low;
    }
}
```

## 153. Find Minimum in Rotated Sorted Array
