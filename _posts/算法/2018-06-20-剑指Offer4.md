---
layout: post
title:  剑指Offer 字符串数组相关问题
date:   2018-06-20 19:15:10
categories:  算法
tags:  剑指Offer
keywords: 
description:         
---
## 剑指Offer 3 数组中重复的数字
## 剑指Offer 4 二维数组的查找
## 剑指Offer 5 替换空格
**请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。**

思路：使用StringBuilder,可以很容易的解决该问题。这样时间复杂度O(n) 空间复杂度也是O(n)
```
public class Solution {
    public String replaceSpace(StringBuffer str) {
        StringBuilder out = new StringBuilder();
        for (int i = 0; i < str.toString().length(); i++) {
            char b=str.charAt(i);
            if(String.valueOf(b).equals(" ")){
                out.append("%20");
            }else{
                out.append(b);
            }
        }
        return out.toString();      
    }
}
```

## 剑指Offer 11 旋转数组的最小数字
**把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。**

思路：题意为两个升序的子串，很明显用二分查找来做效率最快，时间复杂度为O(logn).
```
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        int low = 0 ; int high = array.length - 1;   
        while(low <= high){
            int mid = low + (high - low) / 2;        
            if(array[mid] > array[high]){
                low = mid + 1;
            }else if(array[mid] < array[high]){
                high = mid;                           //注意不可以为high = mid -1
            }else{                                    //数组可能有重复
                high = high - 1; 
            }
        }
        return array[low];
    }
}
```
## 剑指Offer 20 表示数值的字符串
**请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100","5e2","-123","3.1416"和"-1E-16"都表示数值。 但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是。**

## 剑指Offer 21 调整数字顺序使奇数位于偶数前面
**输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。**

思路：我们能够很快的想到快排的思想，用两个指针分别指着数组两端，两端遇到奇数和偶数就交换，但是这题还需要奇数和偶数之间的相对位置不变，我们可以新建一个数组，计算出奇数一共有多少个，然后分别存入新数组中。
```
public class Solution {
    public int[] reOrderArray(int [] array) {
        int[] result = new int[array.length];
        int left =0;
        int i = 0;
        int k = 0;
        for(int j =0;j<array.length;j++){   //计算奇数有多少个
            if(array[j]%2 == 1)
                k++;
        }
        for (;left<array.length;left++){
            if(array[left]%2 == 1) {
                resulta[i++] = array[left];
            }else{
                result[k++] = array[left];
            }
        }
        return result;
    }
}
```
## 剑指Offer 29 顺时针打印矩阵
**输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.**

```
1  2  3  4
5  6  7  8
9  10 11 12
13 14 15 16
```
思路：这题并不难，主要是细心
```
public class Solution {
    ArrayList<Integer> list = new ArrayList<>();
    public ArrayList<Integer> printMatrix(int [][] matrix) {
        int rows = matrix.length;
        int columns = matrix[0].length;
        int start = 0;
        while(list.size()<rows*columns){
            printMatrixInCircle(matrix, rows, columns, start);
            start++;
        }
        return list;
    }
    
    //打印一圈
    public void printMatrixInCircle(int [][] matrix, int rows, int columns, int start){
        // 从左到右打印一行
        for(int i = start; i < columns - start; i++)
            list.add(matrix[start][i]);
        // 从上到下打印一列
        for(int j = start + 1; j < rows - start; j++)
            list.add(matrix[j][columns - start - 1]);
        // 从右到左打印一行
        for(int m = columns - start - 2; m >= start && rows - start - 1 > start; m--)
            list.add(matrix[rows - start - 1][m]);
        // 从下到上打印一列
        for(int n = rows - start - 2; n >= start + 1 && columns - start - 1 > start; n--)
            list.add(matrix[n][start]);
    }
}
```
## 剑指Offer 38 字符串的排序
**输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba**
**输入描述:输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。**

## 剑指Offer 39 数组中出现次数超过一半的数字
**数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。**

思路：遍历一遍数组，将数组存入HashMap，value值为数字出现的次数，时间复杂度为O（n）
```
import java.util.HashMap;
import java.util.Map;
/*
 * 利用map存值，找出存在最多的数字，若大于长度一半，返回此数，否则返回0
 */
public class Solution {
    public int MoreThanHalfNum_Solution(int [] array) {
        if(array.length==0||array==null)
            return 0;
        Map<Integer,Integer> map=new HashMap<Integer,Integer>();
        for(int i=0;i<array.length;i++){
            if(map.containsKey(array[i])){
                map.put(array[i], map.get(array[i])+1);
            }else{
                map.put(array[i], 1);
            }
        }
        for (Map.Entry<Integer, Integer> entry : map.entrySet()) { 
            if(entry.getValue()>array.length/2)
                return entry.getKey();
        } 
        return 0;
    }
}
```
## 剑指Offer 40 最小的k个数
**输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。**

思路：1.如果可以修改输入的数组，可以用Partition思路，时间复杂度O（n）。找到第k大的数
## 剑指Offer 42 连续子数组的最大和
## 剑指Offer 43 1~n整数中1出现的次数
**求出1~n的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次.**
## 剑指Offer 45 把数组拍成最小的数
## 剑指Offer 46 把数字翻译成字符串
## 剑指Offer 48 最长不重复字子字符串

## 剑指Offer 50 第一个只出现一次的字符
**一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。**
```
public class Solution {
    public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) {
        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();
        for(int a:array){
            if(map.containsKey(a)){
                map.put(a,map.get(a)-1);
            }else{
                map.put(a,1);
            }
        }
        int[] temp = new int[2];
        int i =0;
        for(Map.Entry<Integer,Integer> entry : map.entrySet()){
            if(entry.getValue() == 1){
                temp[i++] = entry.getKey();
            }
        }
        num1[0] = temp[0];
        num2[0] = temp[1];
    }
}
```
## 剑指Offer 51 数组中的逆序对
## 剑指Offer 53 在排序数组中查找数字
**统计一个数字在排序数组中出现的次数。例如{1，2，3，3，3，3，4，5}和数字3，由于3在数组中出现了4次，因此输出4**

思路：遍历一遍就行了，时间复杂度O(n)
```
public class Solution {
    public int GetNumberOfK(int [] array , int k) {
       if (array == null || array.length == 0)  return num;
       int sum = 0;
       for(int i : array){
           if(i == k){
               sum++;
           }
       }
       return sum;
    }
}
```
或者用二分查找,速度更快,时间复杂度O（logn）
```
public class Solution {
    public int GetNumberOfK(int [] array , int k) {
        int length = array.length;
        if(length == 0){
            return 0;
        }
        int firstK = getFirstK(array, k, 0, length-1);  //找到第一个k
        int lastK = getLastK(array, k, 0, length-1);    //找到最后一个k
        if(firstK != -1 && lastK != -1){
             return lastK - firstK + 1;
        }
        return 0;
    }
    //递归
    private int getFirstK(int [] array , int k, int start, int end){
        if(start > end){
            return -1;
        }
        int mid = start + (end-start)/2;
        if(array[mid] > k){
            return getFirstK(array, k, start, mid-1);
        }else if (array[mid] < k){
            return getFirstK(array, k, mid+1, end);
        }else if(mid-1 >=0 && array[mid-1] == k){
            return getFirstK(array, k, start, mid-1);
        }else{
            return mid;
        }
    }
    
    private int getLast(int [] array,int k,int start,int end){
        if(start > end){
            return -1;
        }
        int mid = start + (end-start)/2;
        if(array[mid] > k){
            return ()
        }
    }
```
## 剑指Offer 56 数组中数字出现的次数
## 剑指Offer 57 和为s的数字
**输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。**

思路1：利用HashMap，时间复杂度O（n），空间复杂度O(1),比较常规的思路，这种对无序的数组查找也适用
```
public class Solution {
    public ArrayList<Integer> FindNumbersWithSum(int [] array,int sum) {
        HashMap<Integer,Integer> map =new HashMap<Integer,Integer>();
        ArrayList<Integer> list = new ArrayList<>();     //存放存在和为Sum的数据
        ArrayList<Integer> result = new ArrayList<>();   //输出乘积最小的
        for(int i = 0;i<array.length;i++){
            if(map.containsKey(sum-array[i])){
                list.add(array[i]);
            }else{
                map.put(array[i],i);
            }
        }
        if(list.size() == 0) return list;
        result.add(sum-list.get(list.size()-1));        //乘积最小的一定是最两边的两个数
        result.add(list.get(list.size()-1));
        return result;
    }
}
```
思路2：两个指针指着数组两端
* 若ai + aj == sum，就是答案（相差越远乘积越小）
* 若ai + aj > sum，aj肯定不是答案之一（前面已得出 i 前面的数已是不可能），j -= 1
* 若ai + aj < sum，ai肯定不是答案之一（前面已得出 j 后面的数已是不可能），i += 1
```
public class Solution {
    public ArrayList<Integer> FindNumbersWithSum(int [] array,int sum) {
        ArrayList<Integer> list = new ArrayList<Integer>();
        if (array == null || array.length < 2) return list;
        int i=0,j=array.length-1;
        
        while(i<j){
            if(array[i]+array[j]==sum){
            list.add(array[i]);
            list.add(array[j]);
                return list;
           }else if(array[i]+array[j]>sum){
                j--;
           }else{
                i++;
           }
        }
        return list;
    }
}
```
## 剑指Offer 58 翻转字符串
**输入的是一个英文的句子，要求翻转句子中的单词的顺序，但是单词内的字符的顺序却不能变。例如：输入“I am a student.”输出的则是“student.am I”。 **

思路：先翻转整个句子，然后再逐个翻转单词。
```
public class Solution {
    public String ReverseSentence(String str) {
        char[] chars = str.toCharArray();
        reverse(chars,0,chars.length-1);        //先翻转句子
        int i = 0;
        for(int j=0;j<chars.length;j++){        //再按照单词翻转
            if(chars[j] == ' '){
                reverse(chars,i,j-1);
                i = j+1;
            }
        }
        reverse(chars,i,chars.length-1);        //最后一个单词结尾没有空格，需要单独翻转
        return new String(chars);
    }
    
    private void reverse(char[] chars,int left,int right){
        while(left<right){
            char temp = chars[left];
            chars[left] = chars[right];
            chars[right] = temp;
            left++;
            right--;
        }
    }
}
```
## 剑指Offer 66 构建乘积数组
