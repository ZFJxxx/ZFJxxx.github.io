---
layout: post
title:  剑指Offer 16-18 链表相关
date:   2017-10-08 19:15:10
categories:  算法
tags:  剑指Offer
keywords: String
description:         
---
## Java实现链表
Java中并没有链表的实现，我们要尝试自己实现链表。

![enter image description here](http://p7lixluhf.bkt.clouddn.com/list.jpg)

节点（Node）是由一个需要储存的对象及对下一个节点的引用组成的。也就是说，节点拥有两个成员：储存的对象、对下一个节点的引用。

![enter image description here](http://p7lixluhf.bkt.clouddn.com/list2.jpg)

```
public class MyLink {
    Node head = null; // 头节点

    /**
     * 链表中的节点，data代表节点的值，next是指向下一个节点的引用
     */
    class Node {
        Node next = null;// 节点的引用，指向下一个节点
        int data;// 节点的对象，即内容

        public Node(int data) {
            this.data = data;
        }
	
	public Node(E data,Node<E> next) {
			this.data=data;
			this.next=next;
	}
    }
}
```
## 剑指Offer 16 翻转链表
输入一个链表，反转链表后，输出链表的所有元素。
```
public class solution{
    public ListNode ReverseList(ListNode head){
        if(head==null)
            return null;
        //head为当前节点，如果当前节点为空的话，那就什么也不做，直接返回null；
        ListNode pre = null;
        ListNode next = null;
        //当前节点是head，pre为当前节点的前一节点，next为当前节点的下一节点
        //需要pre和next的目的是让当前节点从pre->head->next1->next2变成pre<-head next1->next2
        //即pre让节点可以反转所指方向，但反转之后如果不用next节点保存next1节点的话，此单链表就此断开了
        //所以需要用到pre和next两个节点
        //1->2->3->4->5
        //1<-2<-3 4->5
        while(head!=null){
            //做循环，如果当前节点不为空的话，始终执行此循环，此循环的目的就是让当前节点从指向next到指向pre
            //如此就可以做到反转链表的效果
            //先用next保存head的下一个节点的信息，保证单链表不会因为失去head节点的原next节点而就此断裂
            next = head.next;
            //保存完next，就可以让head从指向next变成指向pre了，代码如下
            head.next = pre;
            //head指向pre后，就继续依次反转下一个节点
            //让pre，head，next依次向后移动一个节点，继续下一次的指针反转
            pre = head;
            head = next;
        }
        //如果head为null的时候，pre就为最后一个节点了，但是链表已经反转完毕，pre就是反转后链表的第一个节点
        //直接输出pre就是我们想要得到的反转后的链表
        return pre;

    }
}
```
## 剑指Offer 17 合并两个排序的链表
输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。

递归解法
```
public class Solution {
    public ListNode Merge(ListNode list1, ListNode list2) {
         if(list1==null)
             return list2;
         else if(list2==null)
             return list1;
         ListNode mergeHead=null;
         if(list1.val<list2.val){
             mergeHead=list1;
             mergeHead.next=Merge(list1.next, list2);
         } else {
             mergeHead=list2;
             mergeHead.next=Merge(list1, list2.next);
        }
        return mergeHead; 
    }
}
```

## 剑指Offer 18 链表中倒数第k个结点
输入一个链表，输出该链表中倒数第k个结点。

思路如下：两个指针，先让第一个指针和第二个指针都指向头结点，然后再让第一个指正走(k-1)步，到达第k个节点。然后两个指针同时往后移动，因为第一个指针和第二个指针之间相差k，所以当第一个结点到达末尾的时候，第二个结点所在位置就是倒数第k个节点了。

```
public class Solution {
    public ListNode FindKthToTail(ListNode head,int k) {
        if(head==null||k<=0){
            return null;
        }
        ListNode first=head;
        ListNode second=head; 
        //第一个指针向后移动k-1      
        for(int i=1;i<k;i++){
            if(first.next!=null){
                first=first.next;
            }else{
                return null;
            }
        }
        //一起向后移动直到第一个指针指向尾节点
        while(first.next!=null){
            first = first.next;
            second=second.next;
        }
        return second;
	}
}
```
