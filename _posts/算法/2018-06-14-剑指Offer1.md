---
layout: post
title:  剑指Offer 16-18 链表相关
date:   2017-10-08 19:15:10
categories:  算法
tags:  剑指Offer
keywords: String
description:         
---
## Java实现链表
Java中并没有链表的实现，我们要尝试自己实现链表。

![enter image description here](http://p7lixluhf.bkt.clouddn.com/list.jpg)

节点（Node）是由一个需要储存的对象及对下一个节点的引用组成的。也就是说，节点拥有两个成员：储存的对象、对下一个节点的引用。

![enter image description here](http://p7lixluhf.bkt.clouddn.com/list2.jpg)

```
public class MyLinked {
    Node head = null; // 头节点
    int length;  //链表长度

    /**
     * 链表中的节点，data代表节点的值，next是指向下一个节点的引用
     */
    class Node {
        Node next = null;// 节点的引用，指向下一个节点
        int data;// 节点的对象，即内容

        public Node(int data) {
            this.data = data;
        }
    }

    /**
     * 向链表中添加数据
     * @param data
     */
    public void add(int data) {
        Node newNode = new Node(data);// 实例化一个节点
        if (head == null) {
            head = newNode;
            return;
        }
        Node tmp = head;
        while (tmp.next != null) {
            tmp = tmp.next;
        }
        tmp.next = newNode;
        length++;
    }

    /**
     *
     * @param index:删除第index个节点
     * @return
     */
    public boolean delete(int index) {
        if (index < 0 || index > length()) {
            return false;
        }
        if (index == 0) {
            head = head.next;
            length--;
            return true;
        }
        int i = 0;
        Node<E> temp = head;
        while(i<index-1){
            temp = temp.next;
            i++;
        }
        temp.next = temp.next.next;
        length--;
        return false;
    }

    /**
     * 插入节点到位置index
     */
    public boolean insert(int index, int data){
        if(index < 0 || index > length-1)
            return false;
        Node newNode = new Node(data);
        if(index == 0){
            newNode.next = head;
            head = newNode;
            length++;
            return true;
        } else {
            int i = 0;
            Node temp = head;
            while(i<index -1){
                temp = temp.next;
                i++;
            }
            newNode.next = temp.next;
            temp.next = newNode;
            return true;
        }
    }

    /**
     * @return 返回节点长度
     */
    public int length() {
        return length;
    }

    /**
     * 打印链表
     */
    public void print() {
        Node tmp = head;
        System.out.print("[");
        while (tmp != null) {
            System.out.print(tmp.data+ " ");
            tmp = tmp.next;
        }
        System.out.print("]\n");
    }

    public static void main(String[] args) {
        MyLinked list = new MyLinked();
        list.add(5);
        list.add(3);
        list.add(1);
        list.add(2);
        list.add(55);
        list.add(36);
        System.out.println("linkLength:" + list.length());
        System.out.println("head.data:" + list.head.data);
        list.print();
        list.delete(5);
        System.out.print("After deleteNode(4):");
        list.print();
        list.insert(3,99);
        System.out.print("After insert(99):");
        list.print();
    }
}
```
## 剑指Offer 22 链表中倒数第k个结点
输入一个链表，输出该链表中倒数第k个结点。

思路如下：两个指针，先让第一个指针和第二个指针都指向头结点，然后再让第一个指正走(k-1)步，到达第k个节点。然后两个指针同时往后移动，因为第一个指针和第二个指针之间相差k，所以当第一个结点到达末尾的时候，第二个结点所在位置就是倒数第k个节点了。

```
public class Solution {
    public Node FindKthToTail(Node head,int k) {
        if(head == null|| k<=0 || k >= head.length){
            return null;
        }
        Node first = head;
        Node second = head; 
        //第一个指针向后移动k-1      
        for(int i=0;i<k-1;i++){
            first=first.next;
        }
	
        //一起向后移动直到第一个指针指向尾节点
        while(first.next!=null){
            first = first.next;
            second = second.next;
        }
        return second;
   }
}
```

## 剑指Offer 24 翻转链表
输入一个链表，反转链表后，输出链表的所有元素。
```
public class solution{
    public Node ReverseList(Node head){
        if(head == null)     
            return null;
        
	//当前节点是head，pre为当前节点的前一节点，next为当前节点的下一节点
        //需要pre和next的目的是让当前节点从pre->head->next1->next2变成pre<-head next1->next2
        //即pre让节点可以反转所指方向，但反转之后如果不用next节点保存next1节点的话，此单链表就此断开了,所以需要用到pre和next两个节点
        Node pre = null;
        Node next = null;
        Node now = node;
        while (now != null) {
             Node next = now.next;
             now.next = prev;
             prev = now;
             now = next;
        }
        return prev;
    }
}
```

## 剑指Offer 25 合并两个排序的链表
输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。

递归解法
```
public Node Merge(Node head1, Node head2) {
        if(head1 == null)
            return head2;
        else if(head2==null)
            return head1;

        Node mergeHead=null;
        if(head1.data < head2.data){
            mergeHead=head1;
            mergeHead.next=Merge(head1.next, head2);
        } else {
            mergeHead=head2;
            mergeHead.next=Merge(head1, head2.next);
        }
        return mergeHead;
}
```


