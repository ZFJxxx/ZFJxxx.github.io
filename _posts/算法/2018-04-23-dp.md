---
layout: post
title:  Leetcode 动态规划
date:   2018-04-23 11:15:10
categories: 算法
tags: LeetCode
keywords: LeetCode
description: 
---
## 53. Maximum Subarray(最大子序和)
Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.
```
Example:

Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
```
思路：求和，新建一个数组dp[]存储求和最大值，然后判断和是否小于0，因为只要前面的和小于0，那么后面的数加上前面的和就一定比自身小，所以抛弃前面重新求和。

然后dp[]中的最大值就是求和的最大值。

```
// num:[-2,1,-3,4,-1,2,1,-5,4]
//  dp:[-2,1,-2,4,3,5,6,-1,3]
class Solution {
    public int maxSubArray(int[] A) {
        int n = A.length;
        int[] dp = new int[n];    //dp[i]代表以 A[i]为结尾的最大子串和;
        dp[0] = A[0];
        int max = dp[0];
        for(int i = 1; i < n; i++){
            dp[i] = A[i] + (dp[i - 1] > 0 ? dp[i - 1] : 0);
            max = Math.max(max, dp[i]);
        }
        return max;
    }
}
```


## 62. Unique Paths
一个机器人，只能从右或者从下走，请问他从左上角走到右下角一共有多少种方法。
![](http://p7lixluhf.bkt.clouddn.com/robot_maze.png)

思路：

机器人到的gge格子A的方式，为机器人到A的上一格和A的左边一格的方法之和，就有F（m,n） =F（m-1,n）+ F(m,n-1);

## LeetCode 718.Longest Common Substring 最长公共子串
找两个字符串的最长公共子串，这个子串要求在原字符串中是连续的。

思路：

其实这是一个序贯决策问题，可以用动态规划来求解。使用一个二维矩阵来记录中间结果。 
eg： abcd和bca

![](http://p7lixluhf.bkt.clouddn.com/LCS.PNG)

```
public class Solution {
     /*
     * @param A, B: Two string.
     * @return: the length of the longest common substring.
     */
    public int longestCommonSubstring(String A, String B) {
        if(A==null || B==null) return 0;
        int max=0;                      //记录最长子串的大小
        char[] AStr=A.toCharArray();
        char[] BStr=B.toCharArray();
        int lenA=AStr.length;
        int lenB=BStr.length;
      
        int dp[][]=new int[lenA][lenB];  //初始化矩阵
        for(int i=0;i<lenA;i++){
            for(int j=0;j<lenB;j++){
                if(AStr[i]==BStr[j]){  //当charA = charB时
                    if(i==0||j==0){
                        dp[i][j]=1;
                    }else{
                        dp[i][j]=a[i-1][j-1]+1;
                    }
                    max = Math.max(max,dp[i][j]);
                }
                else dp[i][j]=0;
            }
        }
        return max;
    }
}
```
