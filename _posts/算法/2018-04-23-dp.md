---
layout: post
title:  Leetcode 动态规划
date:   2018-04-23 11:15:10
categories: 算法
tags: LeetCode
keywords: LeetCode
description: 
---
## 53. Maximum Subarray(最大子序和)
**给你一个数组，找出其和最大的子序**
```
Example:

Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
```
思路：求和，新建一个数组dp[]存储求和最大值，然后判断和是否小于0，因为只要前面的和小于0，那么后面的数加上前面的和就一定比自身小，所以抛弃前面重新求和。

然后dp[]中的最大值就是求和的最大值。

```
// num:[-2,1,-3,4,-1,2,1,-5,4]
//  dp:[-2,1,-2,4,3,5,6,-1,3]
class Solution {
    public int maxSubArray(int[] A) {
        int n = A.length;
        int[] dp = new int[n];    //dp[i]代表以 A[i]为结尾的最大子串和;
        dp[0] = A[0];
        int max = dp[0];
        for(int i = 1; i < n; i++){
            dp[i] = A[i] + (dp[i - 1] > 0 ? dp[i - 1] : 0);
            max = Math.max(max, dp[i]);
        }
        return max;
    }
}
```


## 62. Unique Paths
**一个机器人，只能从右或者从下走，请问他从左上角走到右下角一共有多少种方法。**
![](http://p7lixluhf.bkt.clouddn.com/robot_maze.png)

```
Example 1:

Input: m = 3, n = 2
Output: 3

dp数组为：
1 1
1 2
1 3
```
思路：

机器人到的格子A的方法，为机器人到A的上一格和A的左边一格的方法之和，就有F（m,n） =F（m-1,n）+ F(m,n-1);

我们得到动态递推式，就很好解决了。

```
 public class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];  
        for(int i = 0;i<m;i++){
            for(int j = 0;j<n;j++){
                if(i == 0)                   //上边界都为1
                    dp[0][j] = 1;
                else if(j == 0)              //左边界都为1
                    dp[i][0] = 1;
                else
                    dp[i][j] = dp[i-1][j]+dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
}
```
## 63. Unique Paths II
**同样也是个机器人，只能从右或者从下走，请问他从左上角走到右下角一共有多少种方法。只不过该题中有障碍，如下面的example，1代表障碍，不能通过该格子。**
![](http://p7lixluhf.bkt.clouddn.com/robot_maze.png)
```
Input:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
Output: 2
Explanation:
There is one obstacle in the middle of the 3x3 grid above.
There are two ways to reach the bottom-right corner:
1. Right -> Right -> Down -> Down
2. Down -> Down -> Right -> Right
```
思路： 方法还是和62. Unique Paths一样，只不过将有障碍的地方的方法设为0就可以了。
```
  [0,0,0]                  [1,1,1]
  [0,1,0]      ->          [1,0,1]
  [0,0,0]                  [1,1,2]
```
```
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        //Empty case
        if(obstacleGrid.length == 0) return 0;
        int rows = obstacleGrid.length;
        int cols = obstacleGrid[0].length;
        int[][] dp = new int[rows][cols];
            
        for(int i = 0; i < rows; i++){
            for(int j = 0; j < cols; j++){
                if(obstacleGrid[i][j] == 1)     //有障碍物的地方设为0
                    dp[i][j] = 0;
                else if(i == 0 && j == 0)
                    dp[i][j] = 1;
                else if(i == 0)                 // 上边界，前面有障碍物后面都为0，没有为1
                    dp[i][j] = dp[i][j - 1];     
                else if(j == 0)                 // 左边界，上面有障碍物后面都为0，没有为1
                    dp[i][j] = dp[i - 1][j];     
                else
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[rows - 1][cols - 1];
    }
}
```

## 64.Minimum Path Sum
从左上角走到右下角，找出路径值加起来最小为多少？

Note: You can only move either down or right at any point in time.
```
Example:

Input:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
Output: 7
Explanation: Because the path 1→3→1→1→1 minimizes the sum.
```
思路：路径值最小和路径值最大，都可以用同一种方法解决。到（m，n）这个点最小的值是其左边坐标和上面坐标中较小的值加上（m,n）这点的值，就有

F（m,n） = Math.min(F(m-1,n),F(m,n-1)) + grid[m][n]

我们同样可以创建一个二维数组，来记录到每个点的最小值。
```
[1,3,1]           [1,4,5]
[1,5,1]    ->     [2,7,6]
[4,2,1]           [6,8,7]
```
```
class Solution {
    public int minPathSum(int[][] grid) {
        int rows = grid.length;
        int cols = grid[0].length;
        int[][] dp = new int[rows][cols];
        
        for(int i = 0;i<rows;i++){
            for(int j = 0;j<cols;j++){
                if(i == 0 && j ==0)
                    dp[i][j] = grid[i][j];
                else if(i == 0)
                    dp[i][j] = grid[i][j] + dp[i][j-1];
                else if(j == 0)
                    dp[i][j] = grid[i][j] + dp[i-1][j];
                else
                    dp[i][j] = Math.min(dp[i-1][j],dp[i][j-1]) + grid[i][j];
            }
        }
        return dp[rows-1][cols-1];
    }
}
```

## 70. Climbing Stairs
**你每次能爬1或者2阶楼梯，问爬到N层能有多少种爬法。**

思路：爬到第N层的方法等于爬到N-1层和N-2层的方法和，所以有动态递推式
```
F(1) = 1;
F(2) = 2;
F(n) = F（n-1）+ F(n-2);

可以用一个数组来存储结果：[1,2,3,5,8,13,21.....]
```
实际上我们并不需要一个数组，我们只要记录dp[n-1],dp[n-2]的值就行了。
```
class Solution {
    public int climbStairs(int n) {
        if(n == 1)
            return 1;
        if(n == 2)
            return 2;
        int a = 1;
        int b = 2;
        int temp = 0;
        for(int i = 2;i<n;i++){
            temp = a+b;
            a = b;      //向后移一位
            b = temp;   //向后移一位
        }
        return temp;
    }
}
```

## 91. Decode Ways
**用1-26代表A - Z，给你一串数字，问有多少种解码方式**
```
Example 1:

Input: "12"
Output: 2
Explanation: It could be decoded as "AB" (1 2) or "L" (12).
Example 2:

Input: "226"
Output: 3
Explanation: It could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).
```
思路：
比如 “12310512”，其可能的解码方式为“123105”和“1231051”两个子串可能的解码方式之和，但是要注意0的存在（0不能单独解码），和后两位大于26的情况（这样就只能单独解码）
```
一般情况： F（12310512） = F（123105） + F（1231051）
为0的情况：F（12310） = F（123）
          F(123105) = F(12310)  
最后两位大于26的情况:F（1231） = F（123）

有 1 2 3 1 0 5 1 2
[1,1,2,3,3,3,3,3,6]  有6种。
```
```
public class Solution {
    public int numDecodings(String s) {
        if (s.isEmpty() || s.charAt(0) - '0' == 0)
            return 0;
        int[] dp = new int[s.length() + 1];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 1; i < s.length(); i++){
            int cur = s.charAt(i) - '0';
            int pre = s.charAt(i-1) - '0';

            if (pre == 0 && cur == 0 || (cur == 0 && (pre * 10 + cur > 26)))  //字符串错误的情况
                return 0;
            else if (pre == 0 || (pre * 10 + cur) > 26)                       //到数第二位为0和最后两位大于26
                dp[i+1] = dp[i];
            else if (cur == 0)                                                //最后一位等于0
                dp[i+1] = dp[i-1];
            else
                dp[i+1] = dp[i] + dp[i-1];
        }
        return dp[s.length()];
    }
}
```

## 120. Triangle
**给你一个三角，然后从顶往下走，只能走邻近的右下或者左下，求走到最低端路径和最小的路径和。**
```
For example, given the following triangle

[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).
```
## 718.Longest Common Substring 最长公共子串
**找两个字符串的最长公共子串，这个子串要求在原字符串中是连续的。**

思路：

其实这是一个序贯决策问题，可以用动态规划来求解。使用一个二维矩阵来记录中间结果。 
eg： abcd和bca

![](http://p7lixluhf.bkt.clouddn.com/LCS.PNG)

```
public class Solution {
     /*
     * @param A, B: Two string.
     * @return: the length of the longest common substring.
     */
    public int longestCommonSubstring(String A, String B) {
        if(A==null || B==null) return 0;
        int max=0;                      //记录最长子串的大小
        char[] AStr=A.toCharArray();
        char[] BStr=B.toCharArray();
        int lenA=AStr.length;
        int lenB=BStr.length;
      
        int dp[][]=new int[lenA][lenB];  //初始化矩阵
        for(int i=0;i<lenA;i++){
            for(int j=0;j<lenB;j++){
                if(AStr[i]==BStr[j]){  //当charA = charB时
                    if(i==0||j==0){
                        dp[i][j]=1;
                    }else{
                        dp[i][j]=a[i-1][j-1]+1;
                    }
                    max = Math.max(max,dp[i][j]);
                }
                else dp[i][j]=0;
            }
        }
        return max;
    }
}
```
