---
layout: post
title:  面试中遇到的一些算法
date:   2018-06-09 19:15:10
categories:  算法
tags:  面经
keywords: 
description:         
---

以下为面试中遇到的一些算法，或者是看到别人面经中的算法，自己拿来写写。

## 美团-输出数组中和为M的所有集合
**n，m。[1,n]中任意个数字加起来为m。字典序输出。**
```
典型的DFS问题，类似于Leetcode的39题
```
```
class solution{
    public  ArrayList<ArrayList<Integer>> nm(int n,int m) {
        int[] nums = new int[n];
        for(int i=1;i<=n;i++){
            nums[i-1] = i;
        }
        ArrayList<ArrayList<Integer>> result = new ArrayList<>();
        DFS(nums,m,result,0, new ArrayList<Integer>());
        return result;
    }

    private  void DFS(int[] nums,int target,ArrayList<ArrayList<Integer>> result,int start,ArrayList<Integer> cur){
        if(target ==0){
            result.add(new ArrayList<Integer>(cur));
            return;
        }
        for(int i = start;i<nums.length;i++){
            if(target >= nums[i]){
                cur.add(nums[i]);
                DFS(nums,target-nums[i],result,i+1,cur);
                cur.remove(cur.size()-1);
            }
        }
    }
}
```

## 网易2018笔试
**给你n个a,m个z组成所有可能的字符串，并将字符串按字典序从小到大排列，输出第k个字符串。**

输入描述:
```
第一行为三个数，分别为a的个数n,z的个数m,第k个字符串。
```
输出描述:
```
第k个字符串
```
```
输入例子1:
2 2 6
输出例子1:
zzaa
```
```
用深度优先列出所有可能全排序，然后再取出
```
```
public class study {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int m = in.nextInt();
        int k = in.nextInt();
        String res = solve(n,m,k);
        System.out.println(res);
    }

    public static String solve(int n,int m,int k){
        ArrayList<String> result = new ArrayList<>();
        StringBuilder cur = new StringBuilder();
        String[] nums = new String[n+m];
        for(int i=0;i<n;i++)
            nums[i] = "a";
        for(int j=n;j<m+n;j++)
            nums[j] = "z";
        DFS(nums,result,new StringBuilder(),new boolean[n+m]);
        return result.get(k-1);
    }

    public static void DFS(String[] nums,ArrayList<String> result,StringBuilder cur,boolean[] used){
        if(cur.length() == nums.length){
            result.add(cur.toString());
            return;
        }
        for(int i = 0;i<nums.length;i++){
            if(used[i])
                continue;
            if(i>0 && nums[i] == nums[i-1]&& !used[i-1])
                continue;
            used[i] = true;
            cur.append(nums[i]);
            DFS(nums,result,cur,used);
            used[i] = false;
            cur.deleteCharAt(cur.length()-1);
        }
    }
}

```
