---
layout: post
title: Spring源码分析（6）IOC流程
date:   2017-10-06 20:15:10
categories:  Java
tags:  Spring
keywords: Spring
description: 
---
----------------------------------

## IOC流程
看了Bean、Context和Core组件的介绍，主要接受了IOC中的几个顶层接口，对Spring的控制反转功能还不是特别清晰，只是对大致框架的作用有个一个初步理解，Bean组件是对Bean进行创建、解析、定义。Context就是个IOC容器。Core类似于一个工具，为Context提供读取外部资源的方法。

IOC容器其实就是Context组件结合其他两个组件共同构建的一个Bean的关系网。接下来我们详细看一下流程。

```
public void test() {
	ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
	SomeBean someBean= (SomeBean) context.getBean("someBean");
	someBean.doSomething();
}
```
首先，还是通过xml文件，创建一个容器context，然后从容器中获取一个bean。我们看看ClassPathXmlApplicationContext的源码,主要看其构造器。
```
public class ClassPathXmlApplicationContext extends AbstractXmlApplicationContext {
       /**
	 * 创建一个新的ClassPathXmlApplicationContext，加载定义
	 * 从给定的XML文件中自动刷新Context
	 * @param xml文件
	 * @throws BeansException if context creation failed
	 * 其中true代表refresh 自动刷新
	 * null代表没有父类
	 */
	public ClassPathXmlApplicationContext(String configLocation) throws BeansException {
		this(new String[] {configLocation}, true, null);
	}
	
    public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)  throws BeansException {  
  
        super(parent);  
        //设置spring的配置文件  
        setConfigLocations(configLocations);  
        if (refresh) {  
            //调用父类的refresh函数，进行一系列初始化  
            refresh();  
        }  
    }  
}
```
我们在来看看ClassPathXmlApplicationContext在框架中的位置，其主要父类为AbstractXmlApplicationContext

![enter image description here](http://p7lixluhf.bkt.clouddn.com/haha.png)

我们看到ClassPathXmlApplicationContext构造器中执行了三个方法，1个是super(parent)，一个是refresh()和setConfigLocations(configLocations)，我们先看super(parent)。

## supre(parent)

ClassPathXmlApplicationContext的父类是AbstractXmlApplicationContext，但是这个方法一直追溯到AbstractApplicationContext类中实现，我们看看主要代码。
```
public abstract class AbstractApplicationContext extends DefaultResourceLoader
		implements ConfigurableApplicationContext {

	//创造一个没有父类的AbstractApplicationContext
	public AbstractApplicationContext() {
		this.resourcePatternResolver = getResourcePatternResolver();
	}
	
	//返回ResourcePatternResolver以用于解析location patterns
	protected ResourcePatternResolver getResourcePatternResolver() {
		return new PathMatchingResourcePatternResolver(this);
	}

	/**
	 * Create a new AbstractApplicationContext with the given parent context.
	 * @param parent the parent context
	 */
	public AbstractApplicationContext(@Nullable ApplicationContext parent) {
		this();
		setParent(parent);
	}

	@Override
	public void setParent(@Nullable ApplicationContext parent) {
		this.parent = parent;
		if (parent != null) {
			Environment parentEnvironment = parent.getEnvironment();
			if (parentEnvironment instanceof ConfigurableEnvironment) {
				getEnvironment().merge((ConfigurableEnvironment) parentEnvironment);
			}
		}
	}
}
```

我们看到而AbstractApplicationContext构造器中有this.resourcePatternResolver = getResourcePatternResolver()，我们在[Spring源码分析（6）Core组件](https://zfjxxx.github.io/2017-10-06-Core/) ResourcePatternResolver是把资源的加载、解析和资源的定义整合在一起的类。


## setConfigLocations(configLocations);
这个方法主要是设置配置路径，
```
public void setConfigLocations(String[] locations) {
    if(locations != null) {
        Assert.noNullElements(locations,"Config locations must not be null");
        this.configLocations = new String[locations.length];
        for(inti = 0; i < locations.length; i++) {
            this.configLocations[i] = resolvePath(locations[i]).trim();
        }
    }else{
        this.configLocations = null;
    }
}
```
resolvePath用于替换${} 占位符，这样就能解析出configLocations

## refresh（）方法
AbstractApplicationContext是ApplicationContext抽象实现类，该抽象类的refresh（）方法定义了Spring容器在加载配置文件后的各项处理过程，也就是上面的自动刷新。这个方法就是构建整个IOC容器过程的完整代码。了解里面的每一行代码，基本上就能了解Spring的原理和功能。

先看AbstractApplicationContext中的refresh（）方法，这段代码主要包含以下步骤
* 构建BeanFactory,以便生产Bean
* 注册可能感兴趣的事件
* 创建Bean的实例对象
* 触发被监听的事件

```
public void refresh() throwsBeansException, IllegalStateException {

    // 整个刷新过程是同步的
    synchronized(this.startupShutdownMonitor) {

        // 刷新前的准备工作
        prepareRefresh();

        // 关闭释放旧的beanFactory创建新的beanFactory，读取配置文件等
        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

        // 对beanFactory进行一些基本的初始化，配置工厂的标准上下文特性，例如Context的ClassLoader和post-processors
        prepareBeanFactory(beanFactory);

        try{
            // 下面两行主要用户扩展，处理所有已注册的BeanFactoryPostProcessor，实现在已经加载配置但未初始化bean时对配置进行修改

            postProcessBeanFactory(beanFactory);
            invokeBeanFactoryPostProcessors(beanFactory);

            // 处理所有已注册的BeanPostProcessor，主要用于扩展，实现bean初始化前后的一些定制操作
            registerBeanPostProcessors(beanFactory);

            // 初始化消息源bean
            initMessageSource();

            // 初始化事件监听器集，也有人叫事件监听器的注册表，所有的事件监听器都在这个bean里进行管理

            initApplicationEventMulticaster();

            // 主要用于扩展，实现一些特殊bean的初始化，时间点是类似消息源事件监听器集等特殊bean初始化后，普通的bean初始化前

            onRefresh();

            // 注册监听器

            registerListeners();

            // 初始化其余的非延迟加载的单例bean

            finishBeanFactoryInitialization(beanFactory);


            // 刷新完成调用LifecycleProcessor的onRefresh方法，并且发布ContextRefreshedEvent事件

            finishRefresh();

        }catch(BeansException ex) {
            // 销毁已经创建的单例bean
            destroyBeans();
            // 重新设置active标记
            cancelRefresh(ex);
            throw ex;
        }
    }
}

```