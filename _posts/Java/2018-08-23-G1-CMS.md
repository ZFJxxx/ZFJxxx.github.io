---
layout: post
title:  G1 CMS垃圾收集器
date:   2018-08-23 19:15:10
categories:  JVM
tags: 思考
keywords: interview
description: 
---
 
 ## CMS收集器
 
 CMS收集器基于“标记-清除”算法实现。它仅仅针对老年代的垃圾回收
 
 整个垃圾收集过程分为4步：
 ```
 1.初始标记
 2.并发标记
 3.重新标记
 4.并发清除
 ```
 
### 初始标记

这个步骤需要“STOP-THE WORLD”，初始标记仅仅标记GC Roots能直接关联到的对象。速度很快
 
### 并发标记
并发标记阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对。并发标记阶段，应用程序的线程和并发标记的线程并发执行，所以用户不会感受到停顿。
 
### 重新标记
 
重新标记为了修正并发标记阶段因Java程序继续运作而导致标记产生变动。 这里也会“STOP-THE-WORLD”

### 并发清理
清理垃圾对象，这个阶段收集器线程和应用程序线程并发执行。

### 缺点
* 1.因为基于“标记-清除”算法，经过CMS收集的堆会产生空间碎片。CMS提供了一个参数在FULL GC时进行内存碎片整理，但是会带来停顿
* 2.因为并发清理阶段，Java程序还在不断产生新的垃圾，无法对这些垃圾一次性的清理完，只能留给下一次GC。所以CMS不能像别人一样在老年代快满的时候才清理。
* 3.因为有两个并发操作，所以对CPU资源很敏感，并发过程可能会导致应用程序变慢。

## G1

G1收集器整体基于“标记-整理”，但是从局部“Region”之间来说是基于“复制算法”

它针对新生代和老年代。
```
1.初始标记
2.并发标记
3.最终标记
4.筛选回收
```

### 初始标记
初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象

### 并发标记
并发标记阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段时耗时较长，但可与用户程序并发执行。

### 最终标记
为了修正并发标记阶段因Java程序继续运作而导致标记产生变动。 这里也会“STOP-THE-WORLD”，但是可并行执行。

这一步会将对象变化记录下来放在log中

### 筛选回收
首先会根据上一步记录的信息对每个"Region"的回收价值做一个排序，根据用户期望的GC停顿时间来制定回收计划。然后清理垃圾

### 优点
* 1.基于“标记-整理”“复制算法”，不会产生不连续的碎片。
* 2.利多并发和并行，基于多CPU减少STOP THE WORLD的时间。
* 3.可预测停顿。

G1将整个Java堆分为一个个小的独立的“Region”，G1通过跟踪每个“Region”回收价值的大小，每次GC优先回收价值大的，所以可以预测停顿。
