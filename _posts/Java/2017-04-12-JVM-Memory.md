---
layout: post
title:   JVM 内存模型
date:   2017-04-12 19:15:10
categories:  Java
tags:  JVM
keywords: JVM
description: 
---

在Java虚拟机规范中，将Java运行时数据划分为6种：

* PC寄存器
* Java栈
* 堆
* 方法区
* 本地方法栈
* 常量池


## PC寄存器
PC寄存器严格来说是一个数据结构，它用于保存当前正常执行的程序的内存地址，同时Java程序是多线程执行的，所以不能一直都按照线性执行下去，当有多个线程交叉执行时，被中断线程的程序当前执行到哪条的内存地址必须要保存下来，以便于它被回复执行时再按照被中断时的指令地址继续执行下去。

## 栈
 栈是和线程联系在一起的，每当创建一个线程，JVM就会为这个线程创建一个对应的Java栈，这个Java栈中又会含有多个栈帧（Frames）,这些栈帧是与每个方法关联起来的，每运行一个方法就创建一个栈帧，每个栈帧会含有一些局部变量、操作栈和方法返回值等信息。
 
每当一个方法执行完成时，这个栈帧就会弹出栈帧元素作为这个方法的返回值，并清除这个栈帧，所以Java栈的栈顶的栈帧就是当前正在执行的活动栈，也就是当前正在执行的方法。PC寄存器也会指向这个地址。只有这个活动的栈帧的本地变量可以被操作栈使用，当这个栈帧中调用另外一个方法时，与之对应的一个新的栈帧又被创建，这个新创建的栈帧被放到Java栈的顶部，变成当前的活动栈帧，当在这个栈帧中所有指令执行完成时这个栈帧移出Java栈，刚才的那个栈帧又变成活动栈帧，前面的栈帧的返回值又变成这个栈帧的操作栈的一个操作数。

前面提到，每个栈帧会含有一些局部变量、操作栈和方法返回值等信息。保存局部变量的值，包括：
* 1.用来保存基本数据类型的值；
* 2.保存类的实例，即堆区对象的引用(指针)。

局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型）

例如这句代码：　　　　　　　　　　　

```
Object obj = new Object();
```

假设这句代码出现在方法体中，那“Object obj”这部分的语义将会反映到Java栈的本地变量表中，作为一个reference类型数据出现。而“new Object()”这部分的语义将会反映到Java堆中，形成一块存储了Object类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（Object Memory Layout）的不同，这块内存的长度是不固定的。另外，在Java堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。 

![enter image description here](http://p7lixluhf.bkt.clouddn.com/JVM-Stack.jpg)

成员变量存放在在堆内存中。静态变量存储于方法区的静态区。
Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。栈的好处就是不需要垃圾回收，随着线程结束内存就释放。
 
## 堆
储new出来的数组或对象 。堆是Java虚拟机所管理的内存中最大的一块。堆是所有线程共享的一块区域，在虚拟机启动时创建。堆的唯一目的是存放对象，几乎所有的对象都在这里分配。

堆是物理上不相连，逻辑上相连的区域。

## 方法区
方法区是用于存储类结构信息的地方，一个Class文件被解析成JVM能识别的几个部分，这些不同的部分在这个class被加载到JVM时，会被存储在不同的数据结构中，其中类信息、常量、静态变量、即时编译器编译后的代码等数据都存在方法区中。

很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。

在Java 8中，永久代被彻底移除，取而代之的是另一块与堆不相连的本地内存——元空间（Metaspace）,从此再也不用关心永久代的内存调优了


## 常量池
常量池是方法区的一部分，也是类里共享的,比如被final修饰的变量，就会进入常量池。它的存储也受方法区的规范约束。常量池中存储了每个class文件中的常量表。


## 本地方法栈
本地方法栈是为JVM运行Native方法准备的空间，它和前面介绍的Java栈的作用类似。

## 示例

两个对象的内存图

![enter image description here](http://p7lixluhf.bkt.clouddn.com/JVM-Stack2.png)

静态变量的内存图

![enter image description here](http://p7lixluhf.bkt.clouddn.com/JVM-Stack3.png)


## PS
* 1.分清什么是实例什么是对象。Class a= new Class();此时a叫实例，而不能说a是对象。实例在栈中，对象在堆中，操作实例实际上是通过实例的指针间接操作对象。多个实例可以指向同一个对象。

* 2.类的成员变量在不同对象中各不相同，都有自己的存储空间(成员变量在堆中的对象中)。而类的方法却是该类的所有对象共享的，只有一套，对象使用方法的时候方法才被压入栈，方法不使用则不占用内存。
