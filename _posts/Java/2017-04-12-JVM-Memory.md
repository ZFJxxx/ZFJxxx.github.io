---
layout: post
title:   JVM 内存模型
date:   2017-04-12 19:15:10
categories:  Java
tags:  JVM
keywords: JVM
description: 
---

在Java虚拟机规范中，将Java运行时数据划分为6种：

* PC寄存器
* Java栈
* 堆
* 方法区
* 本地方法栈
* 常量池


## 栈

栈是和线程联系在一起的，每当创建一个线程，JVM就会为这个线程创建一个对应的Java栈，这个Java栈中又会含有多个栈帧（Frames）,这些栈帧是与每个方法关联起来的，每运行一个方法就创建一个栈帧，每个栈帧会含有一些局部变量、操作栈和方法返回值等信息。
 
每当一个方法执行完成时，这个栈帧就会弹出栈帧元素作为这个方法的返回值，并清除这个栈帧。所以Java栈的栈顶的栈帧就是当前正在执行的活动栈，也就是当前正在执行的方法。PC寄存器也会指向这个地址。只有这个活动的栈帧的本地变量可以被操作栈使用，当这个栈帧中调用另外一个方法时，与之对应的一个新的栈帧又被创建，这个新创建的栈帧被放到Java栈的顶部，变成当前的活动栈帧，当在这个栈帧中所有指令执行完成时这个栈帧移出Java栈，刚才的那个栈帧又变成活动栈帧，前面的栈帧的返回值又变成这个栈帧的操作栈的一个操作数。

前面提到，每个栈帧会含有一些局部变量、方法返回值等信息。保存局部变量的值，包括：
* 1.用来保存基本数据类型的值；
* 2.保存类的实例，即堆区对象的引用(指针)。

局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型）

例如这句代码：　　　　　　　　　　　

```
Object obj = new Object();
```

![enter image description here](http://p7lixluhf.bkt.clouddn.com/JVM-Stack.jpg)

栈的好处就是不需要垃圾回收，随着线程结束内存就释放。

## 本地方法栈
本地方法栈是为JVM运行Native方法准备的空间，它和前面介绍的Java栈的作用类似。

## PC寄存器

PC寄存器用于保存线程执行位置的内存地址，Java程序是多线程执行的，当有多个线程交叉执行时，被中断线程的程序当前执行到哪条的内存地址必须要保存下来，以便于恢复继续执行。


## 堆
储new出来的数组或对象 。堆是Java虚拟机所管理的内存中最大的一块。堆是所有线程共享的一块区域，在虚拟机启动时创建。堆的唯一目的是存放对象，几乎所有的对象都在这里分配。

堆是物理上不相连，逻辑上相连的区域。

## 方法区
方法区是用于存储类结构信息的地方，一个Class文件被解析成JVM能识别的几个部分，这些不同的部分在这个class被加载到JVM时，会被存储在不同的数据结构中，其中类信息、常量、即时编译器编译后的代码等数据都存在方法区中。

## 常量池
常量池是方法区的一部分，也是类里共享的,比如被final修饰的变量，就会进入常量池。它的存储也受方法区的规范约束。常量池中存储了每个class文件中的常量表。


## 示例

两个对象的内存图

![enter image description here](http://p7lixluhf.bkt.clouddn.com/JVM-Stack2.png)

静态变量的内存图

![enter image description here](http://p7lixluhf.bkt.clouddn.com/JVM-Stack3.png)


## PS
* 1.分清什么是实例什么是对象。Class a= new Class();此时a叫实例，而不能说a是对象。实例在栈中，对象在堆中，操作实例实际上是通过实例的指针间接操作对象。多个实例可以指向同一个对象。

* 2.类的成员变量在不同对象中各不相同，都有自己的存储空间(成员变量在堆中的对象中)。而类的方法却是该类的所有对象共享的，只有一套，对象使用方法的时候方法才被压入栈，方法不使用则不占用内存。
