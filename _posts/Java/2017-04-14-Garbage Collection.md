---
layout: post
title:   JVM GC
date:   2017-04-14 19:15:10
categories:  Java
tags:  JVM
keywords: JVM
description: 
---

## Garbage Collection

垃圾回收在面试中被经常提及，要弄懂垃圾回收，首先要先弄懂一个问题
GC是在什么时候，对什么东西，做了什么事情

### 首先“什么时候”

```
* 对象优先在Eden区分配，对于大对象，无法放入survivor区的会被分配到老年代。

* 经过多次Young GC的对象（默认设置为15）就会进入老年代，Young GC之后都会有一部分对象分配到老年代。

* 每次Young GC时会检测所有新生代的对象是否大于老年代的剩余的连续空间：
  1.如果小于，改为直接进行一次Young GC;
  2.如果大于则查看HandlePromotionFailure设置看看是否允许担保失败，
        * 如果不允许，则也要改为进行一次Full GC。
        * 如果允许，则查看历次晋升到老年代的对象平均值是否大于老年代
                * 如果小于那仍然进行Young GC;
                *   如果大于，则进行Full GC;
        
```
```
Full gc的触发条件有多个，FULL GC的时候会STOP THE WORD。
（1）在执行Young gc之前，JVM会进行空间分配担保——如果老年代的连续空间小于新生代对象的总大小（或历次晋升的平均大小），则触发一次full gc。
（2）显式调用System.gc()方法时；
（3）大对象直接进入老年代，从年轻代晋升上来的老对象，尝试在老年代分配内存时，但是老年代内存空间不够；
```
基于分代的堆结构

![enter image description here](http://p7lixluhf.bkt.clouddn.com/JVM-GC.jpg)

### “对什么东西”
从GC root搜索不到，而且经过第一次标记、清理后，仍然没有复活的对象。
需要注意的是，JVM GC只回收堆区和方法区内的对象。而栈区的数据，在超出作用域后会被JVM自动释放掉，所以其不在JVM GC的管理范围内。

判定一个对象死亡，至少经历两次标记过程：如果对象在进行根搜索后，发现没有与GC Roots相连接的引用链，那它将会被第一次标记，并在稍后执行他的finalize()方法（如果它有的话）。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这点是必须的，否则一个对象在finalize()方法执行缓慢，甚至有死循环什么的将会很容易导致整个系统崩溃。finalize()方法是对象最后一次逃脱死亡命运的机会，稍后GC将进行第二次规模稍小的标记，如果在finalize()中对象成功拯救自己（只要重新建立到GC Roots的连接即可，譬如把自己赋值到某个引用上），那在第二次标记时它将被移除出“即将回收”的集合，如果对象这时候还没有逃脱，那基本上它就真的离死不远了。



### “做什么事情”
新生代：复制清理；

老年代：标记-清除和标记-压缩算法；



## 如何判断对象是否存活

Java使用的是可达性分析算法来进行判断，因为**引用计数法**在两个对象相互引用时，无法准确判断GC回收，所以使用**可达性分析算法**

通过一系列称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，搜索路径称为 “引用链”，以下对象可作为GC Roots：

* （1）虚拟机栈中引用的对象
* （2）方法区中静态变量引用的对象
* （3）方法区中常量引用的对象
* （4）Native方法引用的对象

当一个对象到 GC Roots 没有任何引用链时，意味着该对象可以被回收。 

![enter image description here](http://p7lixluhf.bkt.clouddn.com/JVM-GC2.png)

图中obj4 obj5 obj6虽然相互有关联，但是他们到GC Roots是不可达的，所以他们被判定成可回收对象。
在可达性分析法中，判定一个对象objA是否可回收，至少要经历两次标记过程：
* 1、如果对象objA到 GC Roots没有引用链，则进行第一次标记。
* 2、如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法。finalize()方法是对象逃脱死亡的最后机会，GC会对队列中的对象进行第二次标记，如果objA在finalize()方法中与引用链上的任何一个对象建立联系，那么在第二次标记时，objA会被移出“即将回收”集合。

## 垃圾收集算法

（1） 标记-清除算法

首先标记出所有需要回收的对象，然后回收所有需要回收的对象

算法缺点：效率问题，标记和清除过程效率都很低；

空间问题，收集之后会产生大量的内存碎片，不利于大对象的分配。

![enter image description here](http://p7lixluhf.bkt.clouddn.com/GCA1.png)

（2）复制算法

复制算法将可用内存划分成大小相等的两块A和B，每次只使用其中一块，当A的内存用完了，就把存活的对象复制到B，并清空A的内存，不仅提高了标记的效率，因为只需要标记存活的对象，同时也避免了内存碎片的问题，代价是可用内存缩小为原来的一半。

这个算法被普遍用在新生代上，因为新生代的对象98%都是“朝生夕死”，所以并不需要按照1：1的比例来划分内存空间，而是将内存分为一块较大的eden空间和2块较少的survivor空间，每次使用eden和其中一块survivor，当回收时将eden和survivor还存活的对象一次过拷贝到另外一块survivor空间上，然后清理掉eden和用过的survivor。Sun Hotspot虚拟机默认eden和survivor的大小比例是8:1，当survivor空间不够用时，需要依赖其他内存（譬如老年代）进行分配担保（Handle Promotion）

![enter image description here](http://p7lixluhf.bkt.clouddn.com/GCA2.png)

（3）标记-整理算法

在老年代中，对象存活率较高，复制算法的效率很低。

在老年代中，对象存活率较高，复制算法的效率很低。在标记-整理算法中，标记出所有存活的对象，并移动到一端，然后直接清理边界以外的内存。标记-整理 算法是在标记-清除 算法之上，又进行了对象的移动排序整理，因此成本更高，但却解决了内存碎片的问题。

![enter image description here](http://p7lixluhf.bkt.clouddn.com/GCA3.png)

（4）分代收集算法

JVM为了优化内存的回收，使用了分代回收的方式，对于新生代内存的回收（Minor GC）主要采用复制算法。而对于老年代的回收（Major GC），大多采用标记-整理算法。
