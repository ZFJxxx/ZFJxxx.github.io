---
layout: post
title:   JVM 类加载机制
date:   2017-04-10 19:15:10
categories:  Java
tags:  JVM
keywords: JVM
description: 
---
Java虚拟机并不关心.class文件的来源是何种语言，其他语言的编译器也可以把程序代码编译成class文件。 

![enter image description here](http://p7lixluhf.bkt.clouddn.com/20170613151253345.jpg)

这里我们具体讲class文件是如何加载进虚拟机？class文件中的信息进入到虚拟机中后会发生什么变化？

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。

其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。

## 加载

类的加载是指，将类的class文件读入内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类的时候，系统都会为之创建一个java.lang.Class对象。

加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：

* 1.通过一个类的全限定名来获取其定义的二进制字节流。
* 2.将二进制字节流代表的类结构转化到运行时数据区的方法区中。
* 3.在Java堆中生成一个代表这个类的java.lang.Class实例(不是这个类的实例)，作为对方法区中这些数据的访问入口。

注意，这里第1条中的二进制字节流并不只是单纯地从Class文件中获取，比如它还可以从Jar包中获取、从网络中获取（最典型的应用便是Applet）、由其他文件生成（JSP应用）等。

相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。

加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在内存中（方法区）创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。

## 验证
验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。
验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全，决定了是否能够承受恶意代码的攻击。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：文件格式的验证、元数据的验证、字节码验证和符号引用验证。

验证阶段虽然重要，但是并不是必须的。如果所运行的代码（包括自己编写的以及第三方包中的代码）都已经被反复验证过，那么就可以考虑使用 -Xverify:none 参数来关闭大部分的类验证措施。

## 准备

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：

* 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。

* 这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。

假设一个类变量的定义为：

```
public static int value = 3；
```

　那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。
　
## 解析

将常量池内的符号引用替换成直接引用。

## 初始化

**在类的初始化阶段，虚拟机负责对类进行初始化，主要是对类变量进行初始化。**

初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在该阶段则是为该变量赋上我们自己设置的值。 

这就是为什么类方法（静态方法）不能调用普通方法或者普通变量。因为类变量以及静态块各相关方法都在准备阶段分配了内存，在初始化阶段就赋予了值，而此时其他普通的变量并没有做到这几步，他们都是在生成实例变量的时候才会进行内存的分配（堆中分配），因此如果静态方法调用了一个普通变量，而此时还没有创建该普通变量的对象，这就会导致系统错误。所以为了避免这种情况，就不允许那样调用了。

在Java类变量制定初始值有两种方式：（1）声明类变量时指定初始值；（2）使用静态初始化块为类变量只当初始值。
```
public class Test{ 
    //声明变量a时指定初始值
    static int a = 1;
    static int b ;
    static int c ;
    static{ 
        //使用静态初始化块为变量b制指定初始值
        b = 6;
    }
}
```


再看如下代码
```
public class Test{ 
    static{ 
        //使用静态初始化块为变量b制指定初始值
        b = 6;
        System.out.println("-----------");
    }
    //声明变量a时指定初始值
    static int a = 5;
    static int b = 9 ;
    static int c ;

    public static void main(String[] args){
        System.out.println(Test.b);
    }
}
```

现在静态代码块中为b赋值，6；接着程序向下执行，再为其赋值为9.Test类的初始化结束后，类变量b为9. 

## ClassLoader

程序在启动的时候，并不会一次性加载程序所要用的所有class文件，而是根据程序的需要，通过Java的类加载机制（ClassLoader）来动态加载某个class文件到内存当中的，从而只有class文件被载入到了内存之后，才能被其它class所引用。所以ClassLoader就是用来动态加载class文件到内存当中用的。

JDK中提供了三个ClassLoader，根据层级从高到低为：

* Bootstrap ClassLoader，启动类加载器，是Java类加载层次中最顶层的类加载器.负责加载JDK中的核心类库。
* Extension ClassLoader，扩展类加载器，负责加载Java的扩展类库,主要加载%JAVA_HOME%\lib\ext目录下的库类。
* App ClassLoader，系统类加载器，主要加载Classpath指定的库类，一般情况下这是程序中的默认类加载器，也是ClassLoader.getSystemClassLoader() 的返回值。（这里的Classpath默认指的是环境变量中配置的Classpath，但是可以在执行Java命令的时候使用-cp 参数来修改当前程序使用的Classpath）

JVM加载类的实现方式，我们称为 双亲委托模型：

如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委托给自己的父加载器，每一层的类加载器都是如此，因此所有的类加载请求最终都应该传送到顶层的Bootstrap ClassLoader中，只有当父加载器反馈自己无法完成加载请求时，子加载器才会尝试自己加载。

### 双亲委托模型的重要用途是为了解决类载入过程中的安全性问题。

假设有一个开发者自己编写了一个名为Java.lang.Object的类，想借此欺骗JVM。现在他要使用自定义ClassLoader来加载自己编写的java.lang.Object类。然而幸运的是，双亲委托模型不会让他成功。因为JVM会优先在Bootstrap ClassLoader的路径下找到java.lang.Object类，并载入它。

### 但是JVM在搜索类的时候，又是如何判定两个class是相同的呢？

JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的。就算两个class是同一份class字节码，如果被两个不同的ClassLoader实例所加载，JVM也会认为它们是两个不同class。
