---
layout: post
title:  CPU多级缓存
date:   2017-03-01 19:15:10
categories:  Java
tags:  Java并发
keywords: 多线程
description: 
---

## CPU多级缓存
我们知道，在多线程并发情况下，一般累加的结果都是做的，为什么会造成这样的结果呢？

![enter image description here](http://p7lixluhf.bkt.clouddn.com/CPUCache.png)

### 为什么需要CPU Cache？

CPU的频率太快了，快到主存跟不上，这样在处理器时钟周期内，CPU常常需要等待主存，浪费资源。所以cache的出现，是为了缓解CPU和内存之间速度的不匹配问题(结构：cpu->cache->memory)

目前CPU缓存的结构越来越复杂，出现了2级甚至3级缓存。

因为主内存的大小远大于CPU缓存，CPU缓存可能会出现缓存不命中的情况，那么CPU缓存的存在还有意义吗？
* 时间局部性：如果某个数据被访问，那么在不久的将来它很可能再次被访问
* 空间局部性：如果某个数据被访问，那么与它相邻的数据很快也能被访问。

正是这样的读取机制使CPU读取缓存的命中率非常高（大多数CPU可达90%左右），也就是说CPU下一次要读取的数据90%都在缓存中，大约10%需要从内存读取。

部分高端CPU还具有三级缓存，每一级缓存中所储存的全部数据都是下一级缓存的一部分，这三种缓存的技术难度和制造成本是相对递减的，所以其容量也是相对递增的。当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。一般来说，每级缓存的命中率大概都在80%左右，也就是说全部数据量的80%都可以在一级缓存中找到，只剩下20%的总数据量才需要从二级缓存、三级缓存或内存中读取。

### CPU多级缓存-缓存一致性(MESI)

MESI为了保证多个CPU缓存中共享数据的一致性，定义了cache line的四种状态，而CPU对cache line的四种操作可能会产生不一致的状态，因此缓存控制器监听到本地操作和远程操作的时候，需要对地址一致的cache line 状态进行一致性修改，从而保证数据在多个缓存之间保持一致性(M:Modified   E:Exclusive   S:Shared   I:Invalid) 

## CPU乱序执行优化
CPU会为了提高代码执行速度而做出违背代码原有顺序的优化。比如
```
a = 1;
flag = ture;
```
这两行代码的执行顺序并不确定，单核会保证执行的结果不受影响，但是多核就可能会有影响。


如果不做任何防护措施，比如我们在A核上执行一个数据写入操作，写在最后写一个标记表示数据已经写入好了，然后在B核上通过判断这个标志来判断这个数据是否已经就绪。
```
if(flag){
	b = a * 2; 
}
```
但是如果标记位先被执行，而写入操作还未执行或者没有从CPU缓存写入到主存中，这样就可能导致最后执行结果是错误的数据。
